// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: krpc.proto

#ifndef PROTOBUF_INCLUDED_krpc_2eproto
#define PROTOBUF_INCLUDED_krpc_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_krpc_2eproto 

namespace protobuf_krpc_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[29];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_krpc_2eproto
namespace krpc {
namespace schema {
class Argument;
class ArgumentDefaultTypeInternal;
extern ArgumentDefaultTypeInternal _Argument_default_instance_;
class Class;
class ClassDefaultTypeInternal;
extern ClassDefaultTypeInternal _Class_default_instance_;
class ConnectionRequest;
class ConnectionRequestDefaultTypeInternal;
extern ConnectionRequestDefaultTypeInternal _ConnectionRequest_default_instance_;
class ConnectionResponse;
class ConnectionResponseDefaultTypeInternal;
extern ConnectionResponseDefaultTypeInternal _ConnectionResponse_default_instance_;
class Dictionary;
class DictionaryDefaultTypeInternal;
extern DictionaryDefaultTypeInternal _Dictionary_default_instance_;
class DictionaryEntry;
class DictionaryEntryDefaultTypeInternal;
extern DictionaryEntryDefaultTypeInternal _DictionaryEntry_default_instance_;
class Enumeration;
class EnumerationDefaultTypeInternal;
extern EnumerationDefaultTypeInternal _Enumeration_default_instance_;
class EnumerationValue;
class EnumerationValueDefaultTypeInternal;
extern EnumerationValueDefaultTypeInternal _EnumerationValue_default_instance_;
class Error;
class ErrorDefaultTypeInternal;
extern ErrorDefaultTypeInternal _Error_default_instance_;
class Event;
class EventDefaultTypeInternal;
extern EventDefaultTypeInternal _Event_default_instance_;
class Exception;
class ExceptionDefaultTypeInternal;
extern ExceptionDefaultTypeInternal _Exception_default_instance_;
class List;
class ListDefaultTypeInternal;
extern ListDefaultTypeInternal _List_default_instance_;
class MultiplexedRequest;
class MultiplexedRequestDefaultTypeInternal;
extern MultiplexedRequestDefaultTypeInternal _MultiplexedRequest_default_instance_;
class MultiplexedResponse;
class MultiplexedResponseDefaultTypeInternal;
extern MultiplexedResponseDefaultTypeInternal _MultiplexedResponse_default_instance_;
class Parameter;
class ParameterDefaultTypeInternal;
extern ParameterDefaultTypeInternal _Parameter_default_instance_;
class Procedure;
class ProcedureDefaultTypeInternal;
extern ProcedureDefaultTypeInternal _Procedure_default_instance_;
class ProcedureCall;
class ProcedureCallDefaultTypeInternal;
extern ProcedureCallDefaultTypeInternal _ProcedureCall_default_instance_;
class ProcedureResult;
class ProcedureResultDefaultTypeInternal;
extern ProcedureResultDefaultTypeInternal _ProcedureResult_default_instance_;
class Request;
class RequestDefaultTypeInternal;
extern RequestDefaultTypeInternal _Request_default_instance_;
class Response;
class ResponseDefaultTypeInternal;
extern ResponseDefaultTypeInternal _Response_default_instance_;
class Service;
class ServiceDefaultTypeInternal;
extern ServiceDefaultTypeInternal _Service_default_instance_;
class Services;
class ServicesDefaultTypeInternal;
extern ServicesDefaultTypeInternal _Services_default_instance_;
class Set;
class SetDefaultTypeInternal;
extern SetDefaultTypeInternal _Set_default_instance_;
class Status;
class StatusDefaultTypeInternal;
extern StatusDefaultTypeInternal _Status_default_instance_;
class Stream;
class StreamDefaultTypeInternal;
extern StreamDefaultTypeInternal _Stream_default_instance_;
class StreamResult;
class StreamResultDefaultTypeInternal;
extern StreamResultDefaultTypeInternal _StreamResult_default_instance_;
class StreamUpdate;
class StreamUpdateDefaultTypeInternal;
extern StreamUpdateDefaultTypeInternal _StreamUpdate_default_instance_;
class Tuple;
class TupleDefaultTypeInternal;
extern TupleDefaultTypeInternal _Tuple_default_instance_;
class Type;
class TypeDefaultTypeInternal;
extern TypeDefaultTypeInternal _Type_default_instance_;
}  // namespace schema
}  // namespace krpc
namespace google {
namespace protobuf {
template<> ::krpc::schema::Argument* Arena::CreateMaybeMessage<::krpc::schema::Argument>(Arena*);
template<> ::krpc::schema::Class* Arena::CreateMaybeMessage<::krpc::schema::Class>(Arena*);
template<> ::krpc::schema::ConnectionRequest* Arena::CreateMaybeMessage<::krpc::schema::ConnectionRequest>(Arena*);
template<> ::krpc::schema::ConnectionResponse* Arena::CreateMaybeMessage<::krpc::schema::ConnectionResponse>(Arena*);
template<> ::krpc::schema::Dictionary* Arena::CreateMaybeMessage<::krpc::schema::Dictionary>(Arena*);
template<> ::krpc::schema::DictionaryEntry* Arena::CreateMaybeMessage<::krpc::schema::DictionaryEntry>(Arena*);
template<> ::krpc::schema::Enumeration* Arena::CreateMaybeMessage<::krpc::schema::Enumeration>(Arena*);
template<> ::krpc::schema::EnumerationValue* Arena::CreateMaybeMessage<::krpc::schema::EnumerationValue>(Arena*);
template<> ::krpc::schema::Error* Arena::CreateMaybeMessage<::krpc::schema::Error>(Arena*);
template<> ::krpc::schema::Event* Arena::CreateMaybeMessage<::krpc::schema::Event>(Arena*);
template<> ::krpc::schema::Exception* Arena::CreateMaybeMessage<::krpc::schema::Exception>(Arena*);
template<> ::krpc::schema::List* Arena::CreateMaybeMessage<::krpc::schema::List>(Arena*);
template<> ::krpc::schema::MultiplexedRequest* Arena::CreateMaybeMessage<::krpc::schema::MultiplexedRequest>(Arena*);
template<> ::krpc::schema::MultiplexedResponse* Arena::CreateMaybeMessage<::krpc::schema::MultiplexedResponse>(Arena*);
template<> ::krpc::schema::Parameter* Arena::CreateMaybeMessage<::krpc::schema::Parameter>(Arena*);
template<> ::krpc::schema::Procedure* Arena::CreateMaybeMessage<::krpc::schema::Procedure>(Arena*);
template<> ::krpc::schema::ProcedureCall* Arena::CreateMaybeMessage<::krpc::schema::ProcedureCall>(Arena*);
template<> ::krpc::schema::ProcedureResult* Arena::CreateMaybeMessage<::krpc::schema::ProcedureResult>(Arena*);
template<> ::krpc::schema::Request* Arena::CreateMaybeMessage<::krpc::schema::Request>(Arena*);
template<> ::krpc::schema::Response* Arena::CreateMaybeMessage<::krpc::schema::Response>(Arena*);
template<> ::krpc::schema::Service* Arena::CreateMaybeMessage<::krpc::schema::Service>(Arena*);
template<> ::krpc::schema::Services* Arena::CreateMaybeMessage<::krpc::schema::Services>(Arena*);
template<> ::krpc::schema::Set* Arena::CreateMaybeMessage<::krpc::schema::Set>(Arena*);
template<> ::krpc::schema::Status* Arena::CreateMaybeMessage<::krpc::schema::Status>(Arena*);
template<> ::krpc::schema::Stream* Arena::CreateMaybeMessage<::krpc::schema::Stream>(Arena*);
template<> ::krpc::schema::StreamResult* Arena::CreateMaybeMessage<::krpc::schema::StreamResult>(Arena*);
template<> ::krpc::schema::StreamUpdate* Arena::CreateMaybeMessage<::krpc::schema::StreamUpdate>(Arena*);
template<> ::krpc::schema::Tuple* Arena::CreateMaybeMessage<::krpc::schema::Tuple>(Arena*);
template<> ::krpc::schema::Type* Arena::CreateMaybeMessage<::krpc::schema::Type>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace krpc {
namespace schema {

enum ConnectionRequest_Type {
  ConnectionRequest_Type_RPC = 0,
  ConnectionRequest_Type_STREAM = 1,
  ConnectionRequest_Type_ConnectionRequest_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ConnectionRequest_Type_ConnectionRequest_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ConnectionRequest_Type_IsValid(int value);
const ConnectionRequest_Type ConnectionRequest_Type_Type_MIN = ConnectionRequest_Type_RPC;
const ConnectionRequest_Type ConnectionRequest_Type_Type_MAX = ConnectionRequest_Type_STREAM;
const int ConnectionRequest_Type_Type_ARRAYSIZE = ConnectionRequest_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* ConnectionRequest_Type_descriptor();
inline const ::std::string& ConnectionRequest_Type_Name(ConnectionRequest_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    ConnectionRequest_Type_descriptor(), value);
}
inline bool ConnectionRequest_Type_Parse(
    const ::std::string& name, ConnectionRequest_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ConnectionRequest_Type>(
    ConnectionRequest_Type_descriptor(), name, value);
}
enum ConnectionResponse_Status {
  ConnectionResponse_Status_OK = 0,
  ConnectionResponse_Status_MALFORMED_MESSAGE = 1,
  ConnectionResponse_Status_TIMEOUT = 2,
  ConnectionResponse_Status_WRONG_TYPE = 3,
  ConnectionResponse_Status_ConnectionResponse_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ConnectionResponse_Status_ConnectionResponse_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ConnectionResponse_Status_IsValid(int value);
const ConnectionResponse_Status ConnectionResponse_Status_Status_MIN = ConnectionResponse_Status_OK;
const ConnectionResponse_Status ConnectionResponse_Status_Status_MAX = ConnectionResponse_Status_WRONG_TYPE;
const int ConnectionResponse_Status_Status_ARRAYSIZE = ConnectionResponse_Status_Status_MAX + 1;

const ::google::protobuf::EnumDescriptor* ConnectionResponse_Status_descriptor();
inline const ::std::string& ConnectionResponse_Status_Name(ConnectionResponse_Status value) {
  return ::google::protobuf::internal::NameOfEnum(
    ConnectionResponse_Status_descriptor(), value);
}
inline bool ConnectionResponse_Status_Parse(
    const ::std::string& name, ConnectionResponse_Status* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ConnectionResponse_Status>(
    ConnectionResponse_Status_descriptor(), name, value);
}
enum Procedure_GameScene {
  Procedure_GameScene_SPACE_CENTER = 0,
  Procedure_GameScene_FLIGHT = 1,
  Procedure_GameScene_TRACKING_STATION = 2,
  Procedure_GameScene_EDITOR_VAB = 3,
  Procedure_GameScene_EDITOR_SPH = 4,
  Procedure_GameScene_MISSION_BUILDER = 5,
  Procedure_GameScene_Procedure_GameScene_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Procedure_GameScene_Procedure_GameScene_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Procedure_GameScene_IsValid(int value);
const Procedure_GameScene Procedure_GameScene_GameScene_MIN = Procedure_GameScene_SPACE_CENTER;
const Procedure_GameScene Procedure_GameScene_GameScene_MAX = Procedure_GameScene_MISSION_BUILDER;
const int Procedure_GameScene_GameScene_ARRAYSIZE = Procedure_GameScene_GameScene_MAX + 1;

const ::google::protobuf::EnumDescriptor* Procedure_GameScene_descriptor();
inline const ::std::string& Procedure_GameScene_Name(Procedure_GameScene value) {
  return ::google::protobuf::internal::NameOfEnum(
    Procedure_GameScene_descriptor(), value);
}
inline bool Procedure_GameScene_Parse(
    const ::std::string& name, Procedure_GameScene* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Procedure_GameScene>(
    Procedure_GameScene_descriptor(), name, value);
}
enum Type_TypeCode {
  Type_TypeCode_NONE = 0,
  Type_TypeCode_DOUBLE = 1,
  Type_TypeCode_FLOAT = 2,
  Type_TypeCode_SINT32 = 3,
  Type_TypeCode_SINT64 = 4,
  Type_TypeCode_UINT32 = 5,
  Type_TypeCode_UINT64 = 6,
  Type_TypeCode_BOOL = 7,
  Type_TypeCode_STRING = 8,
  Type_TypeCode_BYTES = 9,
  Type_TypeCode_CLASS = 100,
  Type_TypeCode_ENUMERATION = 101,
  Type_TypeCode_EVENT = 200,
  Type_TypeCode_PROCEDURE_CALL = 201,
  Type_TypeCode_STREAM = 202,
  Type_TypeCode_STATUS = 203,
  Type_TypeCode_SERVICES = 204,
  Type_TypeCode_TUPLE = 300,
  Type_TypeCode_LIST = 301,
  Type_TypeCode_SET = 302,
  Type_TypeCode_DICTIONARY = 303,
  Type_TypeCode_Type_TypeCode_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Type_TypeCode_Type_TypeCode_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Type_TypeCode_IsValid(int value);
const Type_TypeCode Type_TypeCode_TypeCode_MIN = Type_TypeCode_NONE;
const Type_TypeCode Type_TypeCode_TypeCode_MAX = Type_TypeCode_DICTIONARY;
const int Type_TypeCode_TypeCode_ARRAYSIZE = Type_TypeCode_TypeCode_MAX + 1;

const ::google::protobuf::EnumDescriptor* Type_TypeCode_descriptor();
inline const ::std::string& Type_TypeCode_Name(Type_TypeCode value) {
  return ::google::protobuf::internal::NameOfEnum(
    Type_TypeCode_descriptor(), value);
}
inline bool Type_TypeCode_Parse(
    const ::std::string& name, Type_TypeCode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Type_TypeCode>(
    Type_TypeCode_descriptor(), name, value);
}
// ===================================================================

class ConnectionRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:krpc.schema.ConnectionRequest) */ {
 public:
  ConnectionRequest();
  virtual ~ConnectionRequest();

  ConnectionRequest(const ConnectionRequest& from);

  inline ConnectionRequest& operator=(const ConnectionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ConnectionRequest(ConnectionRequest&& from) noexcept
    : ConnectionRequest() {
    *this = ::std::move(from);
  }

  inline ConnectionRequest& operator=(ConnectionRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ConnectionRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConnectionRequest* internal_default_instance() {
    return reinterpret_cast<const ConnectionRequest*>(
               &_ConnectionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(ConnectionRequest* other);
  friend void swap(ConnectionRequest& a, ConnectionRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ConnectionRequest* New() const final {
    return CreateMaybeMessage<ConnectionRequest>(NULL);
  }

  ConnectionRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ConnectionRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ConnectionRequest& from);
  void MergeFrom(const ConnectionRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConnectionRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ConnectionRequest_Type Type;
  static const Type RPC =
    ConnectionRequest_Type_RPC;
  static const Type STREAM =
    ConnectionRequest_Type_STREAM;
  static inline bool Type_IsValid(int value) {
    return ConnectionRequest_Type_IsValid(value);
  }
  static const Type Type_MIN =
    ConnectionRequest_Type_Type_MIN;
  static const Type Type_MAX =
    ConnectionRequest_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    ConnectionRequest_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return ConnectionRequest_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return ConnectionRequest_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return ConnectionRequest_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // string client_name = 2;
  void clear_client_name();
  static const int kClientNameFieldNumber = 2;
  const ::std::string& client_name() const;
  void set_client_name(const ::std::string& value);
  #if LANG_CXX11
  void set_client_name(::std::string&& value);
  #endif
  void set_client_name(const char* value);
  void set_client_name(const char* value, size_t size);
  ::std::string* mutable_client_name();
  ::std::string* release_client_name();
  void set_allocated_client_name(::std::string* client_name);

  // bytes client_identifier = 3;
  void clear_client_identifier();
  static const int kClientIdentifierFieldNumber = 3;
  const ::std::string& client_identifier() const;
  void set_client_identifier(const ::std::string& value);
  #if LANG_CXX11
  void set_client_identifier(::std::string&& value);
  #endif
  void set_client_identifier(const char* value);
  void set_client_identifier(const void* value, size_t size);
  ::std::string* mutable_client_identifier();
  ::std::string* release_client_identifier();
  void set_allocated_client_identifier(::std::string* client_identifier);

  // .krpc.schema.ConnectionRequest.Type type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::krpc::schema::ConnectionRequest_Type type() const;
  void set_type(::krpc::schema::ConnectionRequest_Type value);

  // @@protoc_insertion_point(class_scope:krpc.schema.ConnectionRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr client_name_;
  ::google::protobuf::internal::ArenaStringPtr client_identifier_;
  int type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_krpc_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ConnectionResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:krpc.schema.ConnectionResponse) */ {
 public:
  ConnectionResponse();
  virtual ~ConnectionResponse();

  ConnectionResponse(const ConnectionResponse& from);

  inline ConnectionResponse& operator=(const ConnectionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ConnectionResponse(ConnectionResponse&& from) noexcept
    : ConnectionResponse() {
    *this = ::std::move(from);
  }

  inline ConnectionResponse& operator=(ConnectionResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ConnectionResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConnectionResponse* internal_default_instance() {
    return reinterpret_cast<const ConnectionResponse*>(
               &_ConnectionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(ConnectionResponse* other);
  friend void swap(ConnectionResponse& a, ConnectionResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ConnectionResponse* New() const final {
    return CreateMaybeMessage<ConnectionResponse>(NULL);
  }

  ConnectionResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ConnectionResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ConnectionResponse& from);
  void MergeFrom(const ConnectionResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConnectionResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ConnectionResponse_Status Status;
  static const Status OK =
    ConnectionResponse_Status_OK;
  static const Status MALFORMED_MESSAGE =
    ConnectionResponse_Status_MALFORMED_MESSAGE;
  static const Status TIMEOUT =
    ConnectionResponse_Status_TIMEOUT;
  static const Status WRONG_TYPE =
    ConnectionResponse_Status_WRONG_TYPE;
  static inline bool Status_IsValid(int value) {
    return ConnectionResponse_Status_IsValid(value);
  }
  static const Status Status_MIN =
    ConnectionResponse_Status_Status_MIN;
  static const Status Status_MAX =
    ConnectionResponse_Status_Status_MAX;
  static const int Status_ARRAYSIZE =
    ConnectionResponse_Status_Status_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Status_descriptor() {
    return ConnectionResponse_Status_descriptor();
  }
  static inline const ::std::string& Status_Name(Status value) {
    return ConnectionResponse_Status_Name(value);
  }
  static inline bool Status_Parse(const ::std::string& name,
      Status* value) {
    return ConnectionResponse_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // string message = 2;
  void clear_message();
  static const int kMessageFieldNumber = 2;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // bytes client_identifier = 3;
  void clear_client_identifier();
  static const int kClientIdentifierFieldNumber = 3;
  const ::std::string& client_identifier() const;
  void set_client_identifier(const ::std::string& value);
  #if LANG_CXX11
  void set_client_identifier(::std::string&& value);
  #endif
  void set_client_identifier(const char* value);
  void set_client_identifier(const void* value, size_t size);
  ::std::string* mutable_client_identifier();
  ::std::string* release_client_identifier();
  void set_allocated_client_identifier(::std::string* client_identifier);

  // .krpc.schema.ConnectionResponse.Status status = 1;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  ::krpc::schema::ConnectionResponse_Status status() const;
  void set_status(::krpc::schema::ConnectionResponse_Status value);

  // @@protoc_insertion_point(class_scope:krpc.schema.ConnectionResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  ::google::protobuf::internal::ArenaStringPtr client_identifier_;
  int status_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_krpc_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Request : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:krpc.schema.Request) */ {
 public:
  Request();
  virtual ~Request();

  Request(const Request& from);

  inline Request& operator=(const Request& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Request(Request&& from) noexcept
    : Request() {
    *this = ::std::move(from);
  }

  inline Request& operator=(Request&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Request& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Request* internal_default_instance() {
    return reinterpret_cast<const Request*>(
               &_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(Request* other);
  friend void swap(Request& a, Request& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Request* New() const final {
    return CreateMaybeMessage<Request>(NULL);
  }

  Request* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Request>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Request& from);
  void MergeFrom(const Request& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Request* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .krpc.schema.ProcedureCall calls = 1;
  int calls_size() const;
  void clear_calls();
  static const int kCallsFieldNumber = 1;
  ::krpc::schema::ProcedureCall* mutable_calls(int index);
  ::google::protobuf::RepeatedPtrField< ::krpc::schema::ProcedureCall >*
      mutable_calls();
  const ::krpc::schema::ProcedureCall& calls(int index) const;
  ::krpc::schema::ProcedureCall* add_calls();
  const ::google::protobuf::RepeatedPtrField< ::krpc::schema::ProcedureCall >&
      calls() const;

  // @@protoc_insertion_point(class_scope:krpc.schema.Request)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::krpc::schema::ProcedureCall > calls_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_krpc_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ProcedureCall : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:krpc.schema.ProcedureCall) */ {
 public:
  ProcedureCall();
  virtual ~ProcedureCall();

  ProcedureCall(const ProcedureCall& from);

  inline ProcedureCall& operator=(const ProcedureCall& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProcedureCall(ProcedureCall&& from) noexcept
    : ProcedureCall() {
    *this = ::std::move(from);
  }

  inline ProcedureCall& operator=(ProcedureCall&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ProcedureCall& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProcedureCall* internal_default_instance() {
    return reinterpret_cast<const ProcedureCall*>(
               &_ProcedureCall_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(ProcedureCall* other);
  friend void swap(ProcedureCall& a, ProcedureCall& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProcedureCall* New() const final {
    return CreateMaybeMessage<ProcedureCall>(NULL);
  }

  ProcedureCall* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ProcedureCall>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ProcedureCall& from);
  void MergeFrom(const ProcedureCall& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProcedureCall* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .krpc.schema.Argument arguments = 3;
  int arguments_size() const;
  void clear_arguments();
  static const int kArgumentsFieldNumber = 3;
  ::krpc::schema::Argument* mutable_arguments(int index);
  ::google::protobuf::RepeatedPtrField< ::krpc::schema::Argument >*
      mutable_arguments();
  const ::krpc::schema::Argument& arguments(int index) const;
  ::krpc::schema::Argument* add_arguments();
  const ::google::protobuf::RepeatedPtrField< ::krpc::schema::Argument >&
      arguments() const;

  // string service = 1;
  void clear_service();
  static const int kServiceFieldNumber = 1;
  const ::std::string& service() const;
  void set_service(const ::std::string& value);
  #if LANG_CXX11
  void set_service(::std::string&& value);
  #endif
  void set_service(const char* value);
  void set_service(const char* value, size_t size);
  ::std::string* mutable_service();
  ::std::string* release_service();
  void set_allocated_service(::std::string* service);

  // string procedure = 2;
  void clear_procedure();
  static const int kProcedureFieldNumber = 2;
  const ::std::string& procedure() const;
  void set_procedure(const ::std::string& value);
  #if LANG_CXX11
  void set_procedure(::std::string&& value);
  #endif
  void set_procedure(const char* value);
  void set_procedure(const char* value, size_t size);
  ::std::string* mutable_procedure();
  ::std::string* release_procedure();
  void set_allocated_procedure(::std::string* procedure);

  // uint32 service_id = 4;
  void clear_service_id();
  static const int kServiceIdFieldNumber = 4;
  ::google::protobuf::uint32 service_id() const;
  void set_service_id(::google::protobuf::uint32 value);

  // uint32 procedure_id = 5;
  void clear_procedure_id();
  static const int kProcedureIdFieldNumber = 5;
  ::google::protobuf::uint32 procedure_id() const;
  void set_procedure_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:krpc.schema.ProcedureCall)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::krpc::schema::Argument > arguments_;
  ::google::protobuf::internal::ArenaStringPtr service_;
  ::google::protobuf::internal::ArenaStringPtr procedure_;
  ::google::protobuf::uint32 service_id_;
  ::google::protobuf::uint32 procedure_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_krpc_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Argument : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:krpc.schema.Argument) */ {
 public:
  Argument();
  virtual ~Argument();

  Argument(const Argument& from);

  inline Argument& operator=(const Argument& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Argument(Argument&& from) noexcept
    : Argument() {
    *this = ::std::move(from);
  }

  inline Argument& operator=(Argument&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Argument& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Argument* internal_default_instance() {
    return reinterpret_cast<const Argument*>(
               &_Argument_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(Argument* other);
  friend void swap(Argument& a, Argument& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Argument* New() const final {
    return CreateMaybeMessage<Argument>(NULL);
  }

  Argument* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Argument>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Argument& from);
  void MergeFrom(const Argument& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Argument* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes value = 2;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // uint32 position = 1;
  void clear_position();
  static const int kPositionFieldNumber = 1;
  ::google::protobuf::uint32 position() const;
  void set_position(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:krpc.schema.Argument)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  ::google::protobuf::uint32 position_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_krpc_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Response : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:krpc.schema.Response) */ {
 public:
  Response();
  virtual ~Response();

  Response(const Response& from);

  inline Response& operator=(const Response& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Response(Response&& from) noexcept
    : Response() {
    *this = ::std::move(from);
  }

  inline Response& operator=(Response&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Response& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Response* internal_default_instance() {
    return reinterpret_cast<const Response*>(
               &_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(Response* other);
  friend void swap(Response& a, Response& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Response* New() const final {
    return CreateMaybeMessage<Response>(NULL);
  }

  Response* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Response>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Response& from);
  void MergeFrom(const Response& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Response* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .krpc.schema.ProcedureResult results = 2;
  int results_size() const;
  void clear_results();
  static const int kResultsFieldNumber = 2;
  ::krpc::schema::ProcedureResult* mutable_results(int index);
  ::google::protobuf::RepeatedPtrField< ::krpc::schema::ProcedureResult >*
      mutable_results();
  const ::krpc::schema::ProcedureResult& results(int index) const;
  ::krpc::schema::ProcedureResult* add_results();
  const ::google::protobuf::RepeatedPtrField< ::krpc::schema::ProcedureResult >&
      results() const;

  // .krpc.schema.Error error = 1;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 1;
  private:
  const ::krpc::schema::Error& _internal_error() const;
  public:
  const ::krpc::schema::Error& error() const;
  ::krpc::schema::Error* release_error();
  ::krpc::schema::Error* mutable_error();
  void set_allocated_error(::krpc::schema::Error* error);

  // @@protoc_insertion_point(class_scope:krpc.schema.Response)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::krpc::schema::ProcedureResult > results_;
  ::krpc::schema::Error* error_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_krpc_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ProcedureResult : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:krpc.schema.ProcedureResult) */ {
 public:
  ProcedureResult();
  virtual ~ProcedureResult();

  ProcedureResult(const ProcedureResult& from);

  inline ProcedureResult& operator=(const ProcedureResult& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProcedureResult(ProcedureResult&& from) noexcept
    : ProcedureResult() {
    *this = ::std::move(from);
  }

  inline ProcedureResult& operator=(ProcedureResult&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ProcedureResult& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProcedureResult* internal_default_instance() {
    return reinterpret_cast<const ProcedureResult*>(
               &_ProcedureResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(ProcedureResult* other);
  friend void swap(ProcedureResult& a, ProcedureResult& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProcedureResult* New() const final {
    return CreateMaybeMessage<ProcedureResult>(NULL);
  }

  ProcedureResult* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ProcedureResult>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ProcedureResult& from);
  void MergeFrom(const ProcedureResult& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProcedureResult* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes value = 2;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // .krpc.schema.Error error = 1;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 1;
  private:
  const ::krpc::schema::Error& _internal_error() const;
  public:
  const ::krpc::schema::Error& error() const;
  ::krpc::schema::Error* release_error();
  ::krpc::schema::Error* mutable_error();
  void set_allocated_error(::krpc::schema::Error* error);

  // @@protoc_insertion_point(class_scope:krpc.schema.ProcedureResult)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  ::krpc::schema::Error* error_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_krpc_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Error : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:krpc.schema.Error) */ {
 public:
  Error();
  virtual ~Error();

  Error(const Error& from);

  inline Error& operator=(const Error& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Error(Error&& from) noexcept
    : Error() {
    *this = ::std::move(from);
  }

  inline Error& operator=(Error&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Error& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Error* internal_default_instance() {
    return reinterpret_cast<const Error*>(
               &_Error_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(Error* other);
  friend void swap(Error& a, Error& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Error* New() const final {
    return CreateMaybeMessage<Error>(NULL);
  }

  Error* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Error>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Error& from);
  void MergeFrom(const Error& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Error* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string service = 1;
  void clear_service();
  static const int kServiceFieldNumber = 1;
  const ::std::string& service() const;
  void set_service(const ::std::string& value);
  #if LANG_CXX11
  void set_service(::std::string&& value);
  #endif
  void set_service(const char* value);
  void set_service(const char* value, size_t size);
  ::std::string* mutable_service();
  ::std::string* release_service();
  void set_allocated_service(::std::string* service);

  // string name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string description = 3;
  void clear_description();
  static const int kDescriptionFieldNumber = 3;
  const ::std::string& description() const;
  void set_description(const ::std::string& value);
  #if LANG_CXX11
  void set_description(::std::string&& value);
  #endif
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  ::std::string* mutable_description();
  ::std::string* release_description();
  void set_allocated_description(::std::string* description);

  // string stack_trace = 4;
  void clear_stack_trace();
  static const int kStackTraceFieldNumber = 4;
  const ::std::string& stack_trace() const;
  void set_stack_trace(const ::std::string& value);
  #if LANG_CXX11
  void set_stack_trace(::std::string&& value);
  #endif
  void set_stack_trace(const char* value);
  void set_stack_trace(const char* value, size_t size);
  ::std::string* mutable_stack_trace();
  ::std::string* release_stack_trace();
  void set_allocated_stack_trace(::std::string* stack_trace);

  // @@protoc_insertion_point(class_scope:krpc.schema.Error)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr service_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr description_;
  ::google::protobuf::internal::ArenaStringPtr stack_trace_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_krpc_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class StreamUpdate : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:krpc.schema.StreamUpdate) */ {
 public:
  StreamUpdate();
  virtual ~StreamUpdate();

  StreamUpdate(const StreamUpdate& from);

  inline StreamUpdate& operator=(const StreamUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StreamUpdate(StreamUpdate&& from) noexcept
    : StreamUpdate() {
    *this = ::std::move(from);
  }

  inline StreamUpdate& operator=(StreamUpdate&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const StreamUpdate& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StreamUpdate* internal_default_instance() {
    return reinterpret_cast<const StreamUpdate*>(
               &_StreamUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(StreamUpdate* other);
  friend void swap(StreamUpdate& a, StreamUpdate& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StreamUpdate* New() const final {
    return CreateMaybeMessage<StreamUpdate>(NULL);
  }

  StreamUpdate* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<StreamUpdate>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const StreamUpdate& from);
  void MergeFrom(const StreamUpdate& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamUpdate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .krpc.schema.StreamResult results = 1;
  int results_size() const;
  void clear_results();
  static const int kResultsFieldNumber = 1;
  ::krpc::schema::StreamResult* mutable_results(int index);
  ::google::protobuf::RepeatedPtrField< ::krpc::schema::StreamResult >*
      mutable_results();
  const ::krpc::schema::StreamResult& results(int index) const;
  ::krpc::schema::StreamResult* add_results();
  const ::google::protobuf::RepeatedPtrField< ::krpc::schema::StreamResult >&
      results() const;

  // @@protoc_insertion_point(class_scope:krpc.schema.StreamUpdate)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::krpc::schema::StreamResult > results_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_krpc_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class StreamResult : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:krpc.schema.StreamResult) */ {
 public:
  StreamResult();
  virtual ~StreamResult();

  StreamResult(const StreamResult& from);

  inline StreamResult& operator=(const StreamResult& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StreamResult(StreamResult&& from) noexcept
    : StreamResult() {
    *this = ::std::move(from);
  }

  inline StreamResult& operator=(StreamResult&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const StreamResult& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StreamResult* internal_default_instance() {
    return reinterpret_cast<const StreamResult*>(
               &_StreamResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(StreamResult* other);
  friend void swap(StreamResult& a, StreamResult& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StreamResult* New() const final {
    return CreateMaybeMessage<StreamResult>(NULL);
  }

  StreamResult* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<StreamResult>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const StreamResult& from);
  void MergeFrom(const StreamResult& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamResult* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .krpc.schema.ProcedureResult result = 2;
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 2;
  private:
  const ::krpc::schema::ProcedureResult& _internal_result() const;
  public:
  const ::krpc::schema::ProcedureResult& result() const;
  ::krpc::schema::ProcedureResult* release_result();
  ::krpc::schema::ProcedureResult* mutable_result();
  void set_allocated_result(::krpc::schema::ProcedureResult* result);

  // uint64 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::uint64 id() const;
  void set_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:krpc.schema.StreamResult)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::krpc::schema::ProcedureResult* result_;
  ::google::protobuf::uint64 id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_krpc_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Services : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:krpc.schema.Services) */ {
 public:
  Services();
  virtual ~Services();

  Services(const Services& from);

  inline Services& operator=(const Services& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Services(Services&& from) noexcept
    : Services() {
    *this = ::std::move(from);
  }

  inline Services& operator=(Services&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Services& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Services* internal_default_instance() {
    return reinterpret_cast<const Services*>(
               &_Services_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(Services* other);
  friend void swap(Services& a, Services& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Services* New() const final {
    return CreateMaybeMessage<Services>(NULL);
  }

  Services* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Services>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Services& from);
  void MergeFrom(const Services& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Services* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .krpc.schema.Service services = 1;
  int services_size() const;
  void clear_services();
  static const int kServicesFieldNumber = 1;
  ::krpc::schema::Service* mutable_services(int index);
  ::google::protobuf::RepeatedPtrField< ::krpc::schema::Service >*
      mutable_services();
  const ::krpc::schema::Service& services(int index) const;
  ::krpc::schema::Service* add_services();
  const ::google::protobuf::RepeatedPtrField< ::krpc::schema::Service >&
      services() const;

  // @@protoc_insertion_point(class_scope:krpc.schema.Services)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::krpc::schema::Service > services_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_krpc_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Service : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:krpc.schema.Service) */ {
 public:
  Service();
  virtual ~Service();

  Service(const Service& from);

  inline Service& operator=(const Service& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Service(Service&& from) noexcept
    : Service() {
    *this = ::std::move(from);
  }

  inline Service& operator=(Service&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Service& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Service* internal_default_instance() {
    return reinterpret_cast<const Service*>(
               &_Service_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(Service* other);
  friend void swap(Service& a, Service& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Service* New() const final {
    return CreateMaybeMessage<Service>(NULL);
  }

  Service* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Service>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Service& from);
  void MergeFrom(const Service& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Service* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .krpc.schema.Procedure procedures = 2;
  int procedures_size() const;
  void clear_procedures();
  static const int kProceduresFieldNumber = 2;
  ::krpc::schema::Procedure* mutable_procedures(int index);
  ::google::protobuf::RepeatedPtrField< ::krpc::schema::Procedure >*
      mutable_procedures();
  const ::krpc::schema::Procedure& procedures(int index) const;
  ::krpc::schema::Procedure* add_procedures();
  const ::google::protobuf::RepeatedPtrField< ::krpc::schema::Procedure >&
      procedures() const;

  // repeated .krpc.schema.Class classes = 3;
  int classes_size() const;
  void clear_classes();
  static const int kClassesFieldNumber = 3;
  ::krpc::schema::Class* mutable_classes(int index);
  ::google::protobuf::RepeatedPtrField< ::krpc::schema::Class >*
      mutable_classes();
  const ::krpc::schema::Class& classes(int index) const;
  ::krpc::schema::Class* add_classes();
  const ::google::protobuf::RepeatedPtrField< ::krpc::schema::Class >&
      classes() const;

  // repeated .krpc.schema.Enumeration enumerations = 4;
  int enumerations_size() const;
  void clear_enumerations();
  static const int kEnumerationsFieldNumber = 4;
  ::krpc::schema::Enumeration* mutable_enumerations(int index);
  ::google::protobuf::RepeatedPtrField< ::krpc::schema::Enumeration >*
      mutable_enumerations();
  const ::krpc::schema::Enumeration& enumerations(int index) const;
  ::krpc::schema::Enumeration* add_enumerations();
  const ::google::protobuf::RepeatedPtrField< ::krpc::schema::Enumeration >&
      enumerations() const;

  // repeated .krpc.schema.Exception exceptions = 5;
  int exceptions_size() const;
  void clear_exceptions();
  static const int kExceptionsFieldNumber = 5;
  ::krpc::schema::Exception* mutable_exceptions(int index);
  ::google::protobuf::RepeatedPtrField< ::krpc::schema::Exception >*
      mutable_exceptions();
  const ::krpc::schema::Exception& exceptions(int index) const;
  ::krpc::schema::Exception* add_exceptions();
  const ::google::protobuf::RepeatedPtrField< ::krpc::schema::Exception >&
      exceptions() const;

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string documentation = 6;
  void clear_documentation();
  static const int kDocumentationFieldNumber = 6;
  const ::std::string& documentation() const;
  void set_documentation(const ::std::string& value);
  #if LANG_CXX11
  void set_documentation(::std::string&& value);
  #endif
  void set_documentation(const char* value);
  void set_documentation(const char* value, size_t size);
  ::std::string* mutable_documentation();
  ::std::string* release_documentation();
  void set_allocated_documentation(::std::string* documentation);

  // @@protoc_insertion_point(class_scope:krpc.schema.Service)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::krpc::schema::Procedure > procedures_;
  ::google::protobuf::RepeatedPtrField< ::krpc::schema::Class > classes_;
  ::google::protobuf::RepeatedPtrField< ::krpc::schema::Enumeration > enumerations_;
  ::google::protobuf::RepeatedPtrField< ::krpc::schema::Exception > exceptions_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr documentation_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_krpc_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Procedure : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:krpc.schema.Procedure) */ {
 public:
  Procedure();
  virtual ~Procedure();

  Procedure(const Procedure& from);

  inline Procedure& operator=(const Procedure& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Procedure(Procedure&& from) noexcept
    : Procedure() {
    *this = ::std::move(from);
  }

  inline Procedure& operator=(Procedure&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Procedure& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Procedure* internal_default_instance() {
    return reinterpret_cast<const Procedure*>(
               &_Procedure_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(Procedure* other);
  friend void swap(Procedure& a, Procedure& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Procedure* New() const final {
    return CreateMaybeMessage<Procedure>(NULL);
  }

  Procedure* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Procedure>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Procedure& from);
  void MergeFrom(const Procedure& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Procedure* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Procedure_GameScene GameScene;
  static const GameScene SPACE_CENTER =
    Procedure_GameScene_SPACE_CENTER;
  static const GameScene FLIGHT =
    Procedure_GameScene_FLIGHT;
  static const GameScene TRACKING_STATION =
    Procedure_GameScene_TRACKING_STATION;
  static const GameScene EDITOR_VAB =
    Procedure_GameScene_EDITOR_VAB;
  static const GameScene EDITOR_SPH =
    Procedure_GameScene_EDITOR_SPH;
  static const GameScene MISSION_BUILDER =
    Procedure_GameScene_MISSION_BUILDER;
  static inline bool GameScene_IsValid(int value) {
    return Procedure_GameScene_IsValid(value);
  }
  static const GameScene GameScene_MIN =
    Procedure_GameScene_GameScene_MIN;
  static const GameScene GameScene_MAX =
    Procedure_GameScene_GameScene_MAX;
  static const int GameScene_ARRAYSIZE =
    Procedure_GameScene_GameScene_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  GameScene_descriptor() {
    return Procedure_GameScene_descriptor();
  }
  static inline const ::std::string& GameScene_Name(GameScene value) {
    return Procedure_GameScene_Name(value);
  }
  static inline bool GameScene_Parse(const ::std::string& name,
      GameScene* value) {
    return Procedure_GameScene_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .krpc.schema.Parameter parameters = 2;
  int parameters_size() const;
  void clear_parameters();
  static const int kParametersFieldNumber = 2;
  ::krpc::schema::Parameter* mutable_parameters(int index);
  ::google::protobuf::RepeatedPtrField< ::krpc::schema::Parameter >*
      mutable_parameters();
  const ::krpc::schema::Parameter& parameters(int index) const;
  ::krpc::schema::Parameter* add_parameters();
  const ::google::protobuf::RepeatedPtrField< ::krpc::schema::Parameter >&
      parameters() const;

  // repeated .krpc.schema.Procedure.GameScene game_scenes = 6;
  int game_scenes_size() const;
  void clear_game_scenes();
  static const int kGameScenesFieldNumber = 6;
  ::krpc::schema::Procedure_GameScene game_scenes(int index) const;
  void set_game_scenes(int index, ::krpc::schema::Procedure_GameScene value);
  void add_game_scenes(::krpc::schema::Procedure_GameScene value);
  const ::google::protobuf::RepeatedField<int>& game_scenes() const;
  ::google::protobuf::RepeatedField<int>* mutable_game_scenes();

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string documentation = 5;
  void clear_documentation();
  static const int kDocumentationFieldNumber = 5;
  const ::std::string& documentation() const;
  void set_documentation(const ::std::string& value);
  #if LANG_CXX11
  void set_documentation(::std::string&& value);
  #endif
  void set_documentation(const char* value);
  void set_documentation(const char* value, size_t size);
  ::std::string* mutable_documentation();
  ::std::string* release_documentation();
  void set_allocated_documentation(::std::string* documentation);

  // .krpc.schema.Type return_type = 3;
  bool has_return_type() const;
  void clear_return_type();
  static const int kReturnTypeFieldNumber = 3;
  private:
  const ::krpc::schema::Type& _internal_return_type() const;
  public:
  const ::krpc::schema::Type& return_type() const;
  ::krpc::schema::Type* release_return_type();
  ::krpc::schema::Type* mutable_return_type();
  void set_allocated_return_type(::krpc::schema::Type* return_type);

  // bool return_is_nullable = 4;
  void clear_return_is_nullable();
  static const int kReturnIsNullableFieldNumber = 4;
  bool return_is_nullable() const;
  void set_return_is_nullable(bool value);

  // @@protoc_insertion_point(class_scope:krpc.schema.Procedure)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::krpc::schema::Parameter > parameters_;
  ::google::protobuf::RepeatedField<int> game_scenes_;
  mutable int _game_scenes_cached_byte_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr documentation_;
  ::krpc::schema::Type* return_type_;
  bool return_is_nullable_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_krpc_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Parameter : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:krpc.schema.Parameter) */ {
 public:
  Parameter();
  virtual ~Parameter();

  Parameter(const Parameter& from);

  inline Parameter& operator=(const Parameter& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Parameter(Parameter&& from) noexcept
    : Parameter() {
    *this = ::std::move(from);
  }

  inline Parameter& operator=(Parameter&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Parameter& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Parameter* internal_default_instance() {
    return reinterpret_cast<const Parameter*>(
               &_Parameter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(Parameter* other);
  friend void swap(Parameter& a, Parameter& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Parameter* New() const final {
    return CreateMaybeMessage<Parameter>(NULL);
  }

  Parameter* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Parameter>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Parameter& from);
  void MergeFrom(const Parameter& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Parameter* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // bytes default_value = 3;
  void clear_default_value();
  static const int kDefaultValueFieldNumber = 3;
  const ::std::string& default_value() const;
  void set_default_value(const ::std::string& value);
  #if LANG_CXX11
  void set_default_value(::std::string&& value);
  #endif
  void set_default_value(const char* value);
  void set_default_value(const void* value, size_t size);
  ::std::string* mutable_default_value();
  ::std::string* release_default_value();
  void set_allocated_default_value(::std::string* default_value);

  // .krpc.schema.Type type = 2;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  private:
  const ::krpc::schema::Type& _internal_type() const;
  public:
  const ::krpc::schema::Type& type() const;
  ::krpc::schema::Type* release_type();
  ::krpc::schema::Type* mutable_type();
  void set_allocated_type(::krpc::schema::Type* type);

  // @@protoc_insertion_point(class_scope:krpc.schema.Parameter)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr default_value_;
  ::krpc::schema::Type* type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_krpc_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Class : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:krpc.schema.Class) */ {
 public:
  Class();
  virtual ~Class();

  Class(const Class& from);

  inline Class& operator=(const Class& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Class(Class&& from) noexcept
    : Class() {
    *this = ::std::move(from);
  }

  inline Class& operator=(Class&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Class& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Class* internal_default_instance() {
    return reinterpret_cast<const Class*>(
               &_Class_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(Class* other);
  friend void swap(Class& a, Class& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Class* New() const final {
    return CreateMaybeMessage<Class>(NULL);
  }

  Class* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Class>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Class& from);
  void MergeFrom(const Class& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Class* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string documentation = 2;
  void clear_documentation();
  static const int kDocumentationFieldNumber = 2;
  const ::std::string& documentation() const;
  void set_documentation(const ::std::string& value);
  #if LANG_CXX11
  void set_documentation(::std::string&& value);
  #endif
  void set_documentation(const char* value);
  void set_documentation(const char* value, size_t size);
  ::std::string* mutable_documentation();
  ::std::string* release_documentation();
  void set_allocated_documentation(::std::string* documentation);

  // @@protoc_insertion_point(class_scope:krpc.schema.Class)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr documentation_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_krpc_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Enumeration : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:krpc.schema.Enumeration) */ {
 public:
  Enumeration();
  virtual ~Enumeration();

  Enumeration(const Enumeration& from);

  inline Enumeration& operator=(const Enumeration& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Enumeration(Enumeration&& from) noexcept
    : Enumeration() {
    *this = ::std::move(from);
  }

  inline Enumeration& operator=(Enumeration&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Enumeration& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Enumeration* internal_default_instance() {
    return reinterpret_cast<const Enumeration*>(
               &_Enumeration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(Enumeration* other);
  friend void swap(Enumeration& a, Enumeration& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Enumeration* New() const final {
    return CreateMaybeMessage<Enumeration>(NULL);
  }

  Enumeration* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Enumeration>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Enumeration& from);
  void MergeFrom(const Enumeration& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Enumeration* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .krpc.schema.EnumerationValue values = 2;
  int values_size() const;
  void clear_values();
  static const int kValuesFieldNumber = 2;
  ::krpc::schema::EnumerationValue* mutable_values(int index);
  ::google::protobuf::RepeatedPtrField< ::krpc::schema::EnumerationValue >*
      mutable_values();
  const ::krpc::schema::EnumerationValue& values(int index) const;
  ::krpc::schema::EnumerationValue* add_values();
  const ::google::protobuf::RepeatedPtrField< ::krpc::schema::EnumerationValue >&
      values() const;

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string documentation = 3;
  void clear_documentation();
  static const int kDocumentationFieldNumber = 3;
  const ::std::string& documentation() const;
  void set_documentation(const ::std::string& value);
  #if LANG_CXX11
  void set_documentation(::std::string&& value);
  #endif
  void set_documentation(const char* value);
  void set_documentation(const char* value, size_t size);
  ::std::string* mutable_documentation();
  ::std::string* release_documentation();
  void set_allocated_documentation(::std::string* documentation);

  // @@protoc_insertion_point(class_scope:krpc.schema.Enumeration)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::krpc::schema::EnumerationValue > values_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr documentation_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_krpc_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EnumerationValue : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:krpc.schema.EnumerationValue) */ {
 public:
  EnumerationValue();
  virtual ~EnumerationValue();

  EnumerationValue(const EnumerationValue& from);

  inline EnumerationValue& operator=(const EnumerationValue& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EnumerationValue(EnumerationValue&& from) noexcept
    : EnumerationValue() {
    *this = ::std::move(from);
  }

  inline EnumerationValue& operator=(EnumerationValue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const EnumerationValue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EnumerationValue* internal_default_instance() {
    return reinterpret_cast<const EnumerationValue*>(
               &_EnumerationValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(EnumerationValue* other);
  friend void swap(EnumerationValue& a, EnumerationValue& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EnumerationValue* New() const final {
    return CreateMaybeMessage<EnumerationValue>(NULL);
  }

  EnumerationValue* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EnumerationValue>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EnumerationValue& from);
  void MergeFrom(const EnumerationValue& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EnumerationValue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string documentation = 3;
  void clear_documentation();
  static const int kDocumentationFieldNumber = 3;
  const ::std::string& documentation() const;
  void set_documentation(const ::std::string& value);
  #if LANG_CXX11
  void set_documentation(::std::string&& value);
  #endif
  void set_documentation(const char* value);
  void set_documentation(const char* value, size_t size);
  ::std::string* mutable_documentation();
  ::std::string* release_documentation();
  void set_allocated_documentation(::std::string* documentation);

  // int32 value = 2;
  void clear_value();
  static const int kValueFieldNumber = 2;
  ::google::protobuf::int32 value() const;
  void set_value(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:krpc.schema.EnumerationValue)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr documentation_;
  ::google::protobuf::int32 value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_krpc_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Exception : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:krpc.schema.Exception) */ {
 public:
  Exception();
  virtual ~Exception();

  Exception(const Exception& from);

  inline Exception& operator=(const Exception& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Exception(Exception&& from) noexcept
    : Exception() {
    *this = ::std::move(from);
  }

  inline Exception& operator=(Exception&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Exception& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Exception* internal_default_instance() {
    return reinterpret_cast<const Exception*>(
               &_Exception_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(Exception* other);
  friend void swap(Exception& a, Exception& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Exception* New() const final {
    return CreateMaybeMessage<Exception>(NULL);
  }

  Exception* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Exception>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Exception& from);
  void MergeFrom(const Exception& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Exception* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string documentation = 2;
  void clear_documentation();
  static const int kDocumentationFieldNumber = 2;
  const ::std::string& documentation() const;
  void set_documentation(const ::std::string& value);
  #if LANG_CXX11
  void set_documentation(::std::string&& value);
  #endif
  void set_documentation(const char* value);
  void set_documentation(const char* value, size_t size);
  ::std::string* mutable_documentation();
  ::std::string* release_documentation();
  void set_allocated_documentation(::std::string* documentation);

  // @@protoc_insertion_point(class_scope:krpc.schema.Exception)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr documentation_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_krpc_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Type : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:krpc.schema.Type) */ {
 public:
  Type();
  virtual ~Type();

  Type(const Type& from);

  inline Type& operator=(const Type& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Type(Type&& from) noexcept
    : Type() {
    *this = ::std::move(from);
  }

  inline Type& operator=(Type&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Type& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Type* internal_default_instance() {
    return reinterpret_cast<const Type*>(
               &_Type_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(Type* other);
  friend void swap(Type& a, Type& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Type* New() const final {
    return CreateMaybeMessage<Type>(NULL);
  }

  Type* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Type>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Type& from);
  void MergeFrom(const Type& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Type* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Type_TypeCode TypeCode;
  static const TypeCode NONE =
    Type_TypeCode_NONE;
  static const TypeCode DOUBLE =
    Type_TypeCode_DOUBLE;
  static const TypeCode FLOAT =
    Type_TypeCode_FLOAT;
  static const TypeCode SINT32 =
    Type_TypeCode_SINT32;
  static const TypeCode SINT64 =
    Type_TypeCode_SINT64;
  static const TypeCode UINT32 =
    Type_TypeCode_UINT32;
  static const TypeCode UINT64 =
    Type_TypeCode_UINT64;
  static const TypeCode BOOL =
    Type_TypeCode_BOOL;
  static const TypeCode STRING =
    Type_TypeCode_STRING;
  static const TypeCode BYTES =
    Type_TypeCode_BYTES;
  static const TypeCode CLASS =
    Type_TypeCode_CLASS;
  static const TypeCode ENUMERATION =
    Type_TypeCode_ENUMERATION;
  static const TypeCode EVENT =
    Type_TypeCode_EVENT;
  static const TypeCode PROCEDURE_CALL =
    Type_TypeCode_PROCEDURE_CALL;
  static const TypeCode STREAM =
    Type_TypeCode_STREAM;
  static const TypeCode STATUS =
    Type_TypeCode_STATUS;
  static const TypeCode SERVICES =
    Type_TypeCode_SERVICES;
  static const TypeCode TUPLE =
    Type_TypeCode_TUPLE;
  static const TypeCode LIST =
    Type_TypeCode_LIST;
  static const TypeCode SET =
    Type_TypeCode_SET;
  static const TypeCode DICTIONARY =
    Type_TypeCode_DICTIONARY;
  static inline bool TypeCode_IsValid(int value) {
    return Type_TypeCode_IsValid(value);
  }
  static const TypeCode TypeCode_MIN =
    Type_TypeCode_TypeCode_MIN;
  static const TypeCode TypeCode_MAX =
    Type_TypeCode_TypeCode_MAX;
  static const int TypeCode_ARRAYSIZE =
    Type_TypeCode_TypeCode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  TypeCode_descriptor() {
    return Type_TypeCode_descriptor();
  }
  static inline const ::std::string& TypeCode_Name(TypeCode value) {
    return Type_TypeCode_Name(value);
  }
  static inline bool TypeCode_Parse(const ::std::string& name,
      TypeCode* value) {
    return Type_TypeCode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .krpc.schema.Type types = 4;
  int types_size() const;
  void clear_types();
  static const int kTypesFieldNumber = 4;
  ::krpc::schema::Type* mutable_types(int index);
  ::google::protobuf::RepeatedPtrField< ::krpc::schema::Type >*
      mutable_types();
  const ::krpc::schema::Type& types(int index) const;
  ::krpc::schema::Type* add_types();
  const ::google::protobuf::RepeatedPtrField< ::krpc::schema::Type >&
      types() const;

  // string service = 2;
  void clear_service();
  static const int kServiceFieldNumber = 2;
  const ::std::string& service() const;
  void set_service(const ::std::string& value);
  #if LANG_CXX11
  void set_service(::std::string&& value);
  #endif
  void set_service(const char* value);
  void set_service(const char* value, size_t size);
  ::std::string* mutable_service();
  ::std::string* release_service();
  void set_allocated_service(::std::string* service);

  // string name = 3;
  void clear_name();
  static const int kNameFieldNumber = 3;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // .krpc.schema.Type.TypeCode code = 1;
  void clear_code();
  static const int kCodeFieldNumber = 1;
  ::krpc::schema::Type_TypeCode code() const;
  void set_code(::krpc::schema::Type_TypeCode value);

  // @@protoc_insertion_point(class_scope:krpc.schema.Type)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::krpc::schema::Type > types_;
  ::google::protobuf::internal::ArenaStringPtr service_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  int code_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_krpc_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Tuple : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:krpc.schema.Tuple) */ {
 public:
  Tuple();
  virtual ~Tuple();

  Tuple(const Tuple& from);

  inline Tuple& operator=(const Tuple& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Tuple(Tuple&& from) noexcept
    : Tuple() {
    *this = ::std::move(from);
  }

  inline Tuple& operator=(Tuple&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Tuple& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Tuple* internal_default_instance() {
    return reinterpret_cast<const Tuple*>(
               &_Tuple_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void Swap(Tuple* other);
  friend void swap(Tuple& a, Tuple& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Tuple* New() const final {
    return CreateMaybeMessage<Tuple>(NULL);
  }

  Tuple* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Tuple>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Tuple& from);
  void MergeFrom(const Tuple& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Tuple* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes items = 1;
  int items_size() const;
  void clear_items();
  static const int kItemsFieldNumber = 1;
  const ::std::string& items(int index) const;
  ::std::string* mutable_items(int index);
  void set_items(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_items(int index, ::std::string&& value);
  #endif
  void set_items(int index, const char* value);
  void set_items(int index, const void* value, size_t size);
  ::std::string* add_items();
  void add_items(const ::std::string& value);
  #if LANG_CXX11
  void add_items(::std::string&& value);
  #endif
  void add_items(const char* value);
  void add_items(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& items() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_items();

  // @@protoc_insertion_point(class_scope:krpc.schema.Tuple)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> items_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_krpc_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class List : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:krpc.schema.List) */ {
 public:
  List();
  virtual ~List();

  List(const List& from);

  inline List& operator=(const List& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  List(List&& from) noexcept
    : List() {
    *this = ::std::move(from);
  }

  inline List& operator=(List&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const List& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const List* internal_default_instance() {
    return reinterpret_cast<const List*>(
               &_List_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  void Swap(List* other);
  friend void swap(List& a, List& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline List* New() const final {
    return CreateMaybeMessage<List>(NULL);
  }

  List* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<List>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const List& from);
  void MergeFrom(const List& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(List* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes items = 1;
  int items_size() const;
  void clear_items();
  static const int kItemsFieldNumber = 1;
  const ::std::string& items(int index) const;
  ::std::string* mutable_items(int index);
  void set_items(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_items(int index, ::std::string&& value);
  #endif
  void set_items(int index, const char* value);
  void set_items(int index, const void* value, size_t size);
  ::std::string* add_items();
  void add_items(const ::std::string& value);
  #if LANG_CXX11
  void add_items(::std::string&& value);
  #endif
  void add_items(const char* value);
  void add_items(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& items() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_items();

  // @@protoc_insertion_point(class_scope:krpc.schema.List)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> items_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_krpc_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Set : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:krpc.schema.Set) */ {
 public:
  Set();
  virtual ~Set();

  Set(const Set& from);

  inline Set& operator=(const Set& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Set(Set&& from) noexcept
    : Set() {
    *this = ::std::move(from);
  }

  inline Set& operator=(Set&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Set& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Set* internal_default_instance() {
    return reinterpret_cast<const Set*>(
               &_Set_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  void Swap(Set* other);
  friend void swap(Set& a, Set& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Set* New() const final {
    return CreateMaybeMessage<Set>(NULL);
  }

  Set* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Set>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Set& from);
  void MergeFrom(const Set& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Set* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes items = 1;
  int items_size() const;
  void clear_items();
  static const int kItemsFieldNumber = 1;
  const ::std::string& items(int index) const;
  ::std::string* mutable_items(int index);
  void set_items(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_items(int index, ::std::string&& value);
  #endif
  void set_items(int index, const char* value);
  void set_items(int index, const void* value, size_t size);
  ::std::string* add_items();
  void add_items(const ::std::string& value);
  #if LANG_CXX11
  void add_items(::std::string&& value);
  #endif
  void add_items(const char* value);
  void add_items(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& items() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_items();

  // @@protoc_insertion_point(class_scope:krpc.schema.Set)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> items_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_krpc_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Dictionary : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:krpc.schema.Dictionary) */ {
 public:
  Dictionary();
  virtual ~Dictionary();

  Dictionary(const Dictionary& from);

  inline Dictionary& operator=(const Dictionary& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Dictionary(Dictionary&& from) noexcept
    : Dictionary() {
    *this = ::std::move(from);
  }

  inline Dictionary& operator=(Dictionary&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Dictionary& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Dictionary* internal_default_instance() {
    return reinterpret_cast<const Dictionary*>(
               &_Dictionary_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  void Swap(Dictionary* other);
  friend void swap(Dictionary& a, Dictionary& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Dictionary* New() const final {
    return CreateMaybeMessage<Dictionary>(NULL);
  }

  Dictionary* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Dictionary>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Dictionary& from);
  void MergeFrom(const Dictionary& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Dictionary* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .krpc.schema.DictionaryEntry entries = 1;
  int entries_size() const;
  void clear_entries();
  static const int kEntriesFieldNumber = 1;
  ::krpc::schema::DictionaryEntry* mutable_entries(int index);
  ::google::protobuf::RepeatedPtrField< ::krpc::schema::DictionaryEntry >*
      mutable_entries();
  const ::krpc::schema::DictionaryEntry& entries(int index) const;
  ::krpc::schema::DictionaryEntry* add_entries();
  const ::google::protobuf::RepeatedPtrField< ::krpc::schema::DictionaryEntry >&
      entries() const;

  // @@protoc_insertion_point(class_scope:krpc.schema.Dictionary)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::krpc::schema::DictionaryEntry > entries_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_krpc_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DictionaryEntry : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:krpc.schema.DictionaryEntry) */ {
 public:
  DictionaryEntry();
  virtual ~DictionaryEntry();

  DictionaryEntry(const DictionaryEntry& from);

  inline DictionaryEntry& operator=(const DictionaryEntry& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DictionaryEntry(DictionaryEntry&& from) noexcept
    : DictionaryEntry() {
    *this = ::std::move(from);
  }

  inline DictionaryEntry& operator=(DictionaryEntry&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DictionaryEntry& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DictionaryEntry* internal_default_instance() {
    return reinterpret_cast<const DictionaryEntry*>(
               &_DictionaryEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  void Swap(DictionaryEntry* other);
  friend void swap(DictionaryEntry& a, DictionaryEntry& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DictionaryEntry* New() const final {
    return CreateMaybeMessage<DictionaryEntry>(NULL);
  }

  DictionaryEntry* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DictionaryEntry>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DictionaryEntry& from);
  void MergeFrom(const DictionaryEntry& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DictionaryEntry* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // bytes value = 2;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:krpc.schema.DictionaryEntry)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_krpc_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Stream : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:krpc.schema.Stream) */ {
 public:
  Stream();
  virtual ~Stream();

  Stream(const Stream& from);

  inline Stream& operator=(const Stream& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Stream(Stream&& from) noexcept
    : Stream() {
    *this = ::std::move(from);
  }

  inline Stream& operator=(Stream&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Stream& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Stream* internal_default_instance() {
    return reinterpret_cast<const Stream*>(
               &_Stream_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  void Swap(Stream* other);
  friend void swap(Stream& a, Stream& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Stream* New() const final {
    return CreateMaybeMessage<Stream>(NULL);
  }

  Stream* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Stream>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Stream& from);
  void MergeFrom(const Stream& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Stream* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint64 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::uint64 id() const;
  void set_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:krpc.schema.Stream)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint64 id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_krpc_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Event : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:krpc.schema.Event) */ {
 public:
  Event();
  virtual ~Event();

  Event(const Event& from);

  inline Event& operator=(const Event& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Event(Event&& from) noexcept
    : Event() {
    *this = ::std::move(from);
  }

  inline Event& operator=(Event&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Event& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Event* internal_default_instance() {
    return reinterpret_cast<const Event*>(
               &_Event_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  void Swap(Event* other);
  friend void swap(Event& a, Event& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Event* New() const final {
    return CreateMaybeMessage<Event>(NULL);
  }

  Event* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Event>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Event& from);
  void MergeFrom(const Event& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Event* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .krpc.schema.Stream stream = 1;
  bool has_stream() const;
  void clear_stream();
  static const int kStreamFieldNumber = 1;
  private:
  const ::krpc::schema::Stream& _internal_stream() const;
  public:
  const ::krpc::schema::Stream& stream() const;
  ::krpc::schema::Stream* release_stream();
  ::krpc::schema::Stream* mutable_stream();
  void set_allocated_stream(::krpc::schema::Stream* stream);

  // @@protoc_insertion_point(class_scope:krpc.schema.Event)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::krpc::schema::Stream* stream_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_krpc_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Status : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:krpc.schema.Status) */ {
 public:
  Status();
  virtual ~Status();

  Status(const Status& from);

  inline Status& operator=(const Status& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Status(Status&& from) noexcept
    : Status() {
    *this = ::std::move(from);
  }

  inline Status& operator=(Status&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Status& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Status* internal_default_instance() {
    return reinterpret_cast<const Status*>(
               &_Status_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  void Swap(Status* other);
  friend void swap(Status& a, Status& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Status* New() const final {
    return CreateMaybeMessage<Status>(NULL);
  }

  Status* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Status>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Status& from);
  void MergeFrom(const Status& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Status* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string version = 1;
  void clear_version();
  static const int kVersionFieldNumber = 1;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // uint64 bytes_read = 2;
  void clear_bytes_read();
  static const int kBytesReadFieldNumber = 2;
  ::google::protobuf::uint64 bytes_read() const;
  void set_bytes_read(::google::protobuf::uint64 value);

  // uint64 bytes_written = 3;
  void clear_bytes_written();
  static const int kBytesWrittenFieldNumber = 3;
  ::google::protobuf::uint64 bytes_written() const;
  void set_bytes_written(::google::protobuf::uint64 value);

  // float bytes_read_rate = 4;
  void clear_bytes_read_rate();
  static const int kBytesReadRateFieldNumber = 4;
  float bytes_read_rate() const;
  void set_bytes_read_rate(float value);

  // float bytes_written_rate = 5;
  void clear_bytes_written_rate();
  static const int kBytesWrittenRateFieldNumber = 5;
  float bytes_written_rate() const;
  void set_bytes_written_rate(float value);

  // uint64 rpcs_executed = 6;
  void clear_rpcs_executed();
  static const int kRpcsExecutedFieldNumber = 6;
  ::google::protobuf::uint64 rpcs_executed() const;
  void set_rpcs_executed(::google::protobuf::uint64 value);

  // float rpc_rate = 7;
  void clear_rpc_rate();
  static const int kRpcRateFieldNumber = 7;
  float rpc_rate() const;
  void set_rpc_rate(float value);

  // uint32 max_time_per_update = 9;
  void clear_max_time_per_update();
  static const int kMaxTimePerUpdateFieldNumber = 9;
  ::google::protobuf::uint32 max_time_per_update() const;
  void set_max_time_per_update(::google::protobuf::uint32 value);

  // bool one_rpc_per_update = 8;
  void clear_one_rpc_per_update();
  static const int kOneRpcPerUpdateFieldNumber = 8;
  bool one_rpc_per_update() const;
  void set_one_rpc_per_update(bool value);

  // bool adaptive_rate_control = 10;
  void clear_adaptive_rate_control();
  static const int kAdaptiveRateControlFieldNumber = 10;
  bool adaptive_rate_control() const;
  void set_adaptive_rate_control(bool value);

  // bool blocking_recv = 11;
  void clear_blocking_recv();
  static const int kBlockingRecvFieldNumber = 11;
  bool blocking_recv() const;
  void set_blocking_recv(bool value);

  // uint32 recv_timeout = 12;
  void clear_recv_timeout();
  static const int kRecvTimeoutFieldNumber = 12;
  ::google::protobuf::uint32 recv_timeout() const;
  void set_recv_timeout(::google::protobuf::uint32 value);

  // float time_per_rpc_update = 13;
  void clear_time_per_rpc_update();
  static const int kTimePerRpcUpdateFieldNumber = 13;
  float time_per_rpc_update() const;
  void set_time_per_rpc_update(float value);

  // float poll_time_per_rpc_update = 14;
  void clear_poll_time_per_rpc_update();
  static const int kPollTimePerRpcUpdateFieldNumber = 14;
  float poll_time_per_rpc_update() const;
  void set_poll_time_per_rpc_update(float value);

  // float exec_time_per_rpc_update = 15;
  void clear_exec_time_per_rpc_update();
  static const int kExecTimePerRpcUpdateFieldNumber = 15;
  float exec_time_per_rpc_update() const;
  void set_exec_time_per_rpc_update(float value);

  // uint32 stream_rpcs = 16;
  void clear_stream_rpcs();
  static const int kStreamRpcsFieldNumber = 16;
  ::google::protobuf::uint32 stream_rpcs() const;
  void set_stream_rpcs(::google::protobuf::uint32 value);

  // uint64 stream_rpcs_executed = 17;
  void clear_stream_rpcs_executed();
  static const int kStreamRpcsExecutedFieldNumber = 17;
  ::google::protobuf::uint64 stream_rpcs_executed() const;
  void set_stream_rpcs_executed(::google::protobuf::uint64 value);

  // float stream_rpc_rate = 18;
  void clear_stream_rpc_rate();
  static const int kStreamRpcRateFieldNumber = 18;
  float stream_rpc_rate() const;
  void set_stream_rpc_rate(float value);

  // float time_per_stream_update = 19;
  void clear_time_per_stream_update();
  static const int kTimePerStreamUpdateFieldNumber = 19;
  float time_per_stream_update() const;
  void set_time_per_stream_update(float value);

  // @@protoc_insertion_point(class_scope:krpc.schema.Status)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  ::google::protobuf::uint64 bytes_read_;
  ::google::protobuf::uint64 bytes_written_;
  float bytes_read_rate_;
  float bytes_written_rate_;
  ::google::protobuf::uint64 rpcs_executed_;
  float rpc_rate_;
  ::google::protobuf::uint32 max_time_per_update_;
  bool one_rpc_per_update_;
  bool adaptive_rate_control_;
  bool blocking_recv_;
  ::google::protobuf::uint32 recv_timeout_;
  float time_per_rpc_update_;
  float poll_time_per_rpc_update_;
  float exec_time_per_rpc_update_;
  ::google::protobuf::uint32 stream_rpcs_;
  ::google::protobuf::uint64 stream_rpcs_executed_;
  float stream_rpc_rate_;
  float time_per_stream_update_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_krpc_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MultiplexedRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:krpc.schema.MultiplexedRequest) */ {
 public:
  MultiplexedRequest();
  virtual ~MultiplexedRequest();

  MultiplexedRequest(const MultiplexedRequest& from);

  inline MultiplexedRequest& operator=(const MultiplexedRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MultiplexedRequest(MultiplexedRequest&& from) noexcept
    : MultiplexedRequest() {
    *this = ::std::move(from);
  }

  inline MultiplexedRequest& operator=(MultiplexedRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MultiplexedRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MultiplexedRequest* internal_default_instance() {
    return reinterpret_cast<const MultiplexedRequest*>(
               &_MultiplexedRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  void Swap(MultiplexedRequest* other);
  friend void swap(MultiplexedRequest& a, MultiplexedRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MultiplexedRequest* New() const final {
    return CreateMaybeMessage<MultiplexedRequest>(NULL);
  }

  MultiplexedRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MultiplexedRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MultiplexedRequest& from);
  void MergeFrom(const MultiplexedRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MultiplexedRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .krpc.schema.ConnectionRequest connection_request = 1;
  bool has_connection_request() const;
  void clear_connection_request();
  static const int kConnectionRequestFieldNumber = 1;
  private:
  const ::krpc::schema::ConnectionRequest& _internal_connection_request() const;
  public:
  const ::krpc::schema::ConnectionRequest& connection_request() const;
  ::krpc::schema::ConnectionRequest* release_connection_request();
  ::krpc::schema::ConnectionRequest* mutable_connection_request();
  void set_allocated_connection_request(::krpc::schema::ConnectionRequest* connection_request);

  // .krpc.schema.Request request = 2;
  bool has_request() const;
  void clear_request();
  static const int kRequestFieldNumber = 2;
  private:
  const ::krpc::schema::Request& _internal_request() const;
  public:
  const ::krpc::schema::Request& request() const;
  ::krpc::schema::Request* release_request();
  ::krpc::schema::Request* mutable_request();
  void set_allocated_request(::krpc::schema::Request* request);

  // @@protoc_insertion_point(class_scope:krpc.schema.MultiplexedRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::krpc::schema::ConnectionRequest* connection_request_;
  ::krpc::schema::Request* request_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_krpc_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MultiplexedResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:krpc.schema.MultiplexedResponse) */ {
 public:
  MultiplexedResponse();
  virtual ~MultiplexedResponse();

  MultiplexedResponse(const MultiplexedResponse& from);

  inline MultiplexedResponse& operator=(const MultiplexedResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MultiplexedResponse(MultiplexedResponse&& from) noexcept
    : MultiplexedResponse() {
    *this = ::std::move(from);
  }

  inline MultiplexedResponse& operator=(MultiplexedResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MultiplexedResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MultiplexedResponse* internal_default_instance() {
    return reinterpret_cast<const MultiplexedResponse*>(
               &_MultiplexedResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  void Swap(MultiplexedResponse* other);
  friend void swap(MultiplexedResponse& a, MultiplexedResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MultiplexedResponse* New() const final {
    return CreateMaybeMessage<MultiplexedResponse>(NULL);
  }

  MultiplexedResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MultiplexedResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MultiplexedResponse& from);
  void MergeFrom(const MultiplexedResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MultiplexedResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .krpc.schema.Response response = 1;
  bool has_response() const;
  void clear_response();
  static const int kResponseFieldNumber = 1;
  private:
  const ::krpc::schema::Response& _internal_response() const;
  public:
  const ::krpc::schema::Response& response() const;
  ::krpc::schema::Response* release_response();
  ::krpc::schema::Response* mutable_response();
  void set_allocated_response(::krpc::schema::Response* response);

  // .krpc.schema.StreamUpdate stream_update = 2;
  bool has_stream_update() const;
  void clear_stream_update();
  static const int kStreamUpdateFieldNumber = 2;
  private:
  const ::krpc::schema::StreamUpdate& _internal_stream_update() const;
  public:
  const ::krpc::schema::StreamUpdate& stream_update() const;
  ::krpc::schema::StreamUpdate* release_stream_update();
  ::krpc::schema::StreamUpdate* mutable_stream_update();
  void set_allocated_stream_update(::krpc::schema::StreamUpdate* stream_update);

  // @@protoc_insertion_point(class_scope:krpc.schema.MultiplexedResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::krpc::schema::Response* response_;
  ::krpc::schema::StreamUpdate* stream_update_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_krpc_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ConnectionRequest

// .krpc.schema.ConnectionRequest.Type type = 1;
inline void ConnectionRequest::clear_type() {
  type_ = 0;
}
inline ::krpc::schema::ConnectionRequest_Type ConnectionRequest::type() const {
  // @@protoc_insertion_point(field_get:krpc.schema.ConnectionRequest.type)
  return static_cast< ::krpc::schema::ConnectionRequest_Type >(type_);
}
inline void ConnectionRequest::set_type(::krpc::schema::ConnectionRequest_Type value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:krpc.schema.ConnectionRequest.type)
}

// string client_name = 2;
inline void ConnectionRequest::clear_client_name() {
  client_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ConnectionRequest::client_name() const {
  // @@protoc_insertion_point(field_get:krpc.schema.ConnectionRequest.client_name)
  return client_name_.GetNoArena();
}
inline void ConnectionRequest::set_client_name(const ::std::string& value) {
  
  client_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:krpc.schema.ConnectionRequest.client_name)
}
#if LANG_CXX11
inline void ConnectionRequest::set_client_name(::std::string&& value) {
  
  client_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:krpc.schema.ConnectionRequest.client_name)
}
#endif
inline void ConnectionRequest::set_client_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  client_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:krpc.schema.ConnectionRequest.client_name)
}
inline void ConnectionRequest::set_client_name(const char* value, size_t size) {
  
  client_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:krpc.schema.ConnectionRequest.client_name)
}
inline ::std::string* ConnectionRequest::mutable_client_name() {
  
  // @@protoc_insertion_point(field_mutable:krpc.schema.ConnectionRequest.client_name)
  return client_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ConnectionRequest::release_client_name() {
  // @@protoc_insertion_point(field_release:krpc.schema.ConnectionRequest.client_name)
  
  return client_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ConnectionRequest::set_allocated_client_name(::std::string* client_name) {
  if (client_name != NULL) {
    
  } else {
    
  }
  client_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), client_name);
  // @@protoc_insertion_point(field_set_allocated:krpc.schema.ConnectionRequest.client_name)
}

// bytes client_identifier = 3;
inline void ConnectionRequest::clear_client_identifier() {
  client_identifier_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ConnectionRequest::client_identifier() const {
  // @@protoc_insertion_point(field_get:krpc.schema.ConnectionRequest.client_identifier)
  return client_identifier_.GetNoArena();
}
inline void ConnectionRequest::set_client_identifier(const ::std::string& value) {
  
  client_identifier_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:krpc.schema.ConnectionRequest.client_identifier)
}
#if LANG_CXX11
inline void ConnectionRequest::set_client_identifier(::std::string&& value) {
  
  client_identifier_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:krpc.schema.ConnectionRequest.client_identifier)
}
#endif
inline void ConnectionRequest::set_client_identifier(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  client_identifier_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:krpc.schema.ConnectionRequest.client_identifier)
}
inline void ConnectionRequest::set_client_identifier(const void* value, size_t size) {
  
  client_identifier_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:krpc.schema.ConnectionRequest.client_identifier)
}
inline ::std::string* ConnectionRequest::mutable_client_identifier() {
  
  // @@protoc_insertion_point(field_mutable:krpc.schema.ConnectionRequest.client_identifier)
  return client_identifier_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ConnectionRequest::release_client_identifier() {
  // @@protoc_insertion_point(field_release:krpc.schema.ConnectionRequest.client_identifier)
  
  return client_identifier_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ConnectionRequest::set_allocated_client_identifier(::std::string* client_identifier) {
  if (client_identifier != NULL) {
    
  } else {
    
  }
  client_identifier_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), client_identifier);
  // @@protoc_insertion_point(field_set_allocated:krpc.schema.ConnectionRequest.client_identifier)
}

// -------------------------------------------------------------------

// ConnectionResponse

// .krpc.schema.ConnectionResponse.Status status = 1;
inline void ConnectionResponse::clear_status() {
  status_ = 0;
}
inline ::krpc::schema::ConnectionResponse_Status ConnectionResponse::status() const {
  // @@protoc_insertion_point(field_get:krpc.schema.ConnectionResponse.status)
  return static_cast< ::krpc::schema::ConnectionResponse_Status >(status_);
}
inline void ConnectionResponse::set_status(::krpc::schema::ConnectionResponse_Status value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:krpc.schema.ConnectionResponse.status)
}

// string message = 2;
inline void ConnectionResponse::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ConnectionResponse::message() const {
  // @@protoc_insertion_point(field_get:krpc.schema.ConnectionResponse.message)
  return message_.GetNoArena();
}
inline void ConnectionResponse::set_message(const ::std::string& value) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:krpc.schema.ConnectionResponse.message)
}
#if LANG_CXX11
inline void ConnectionResponse::set_message(::std::string&& value) {
  
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:krpc.schema.ConnectionResponse.message)
}
#endif
inline void ConnectionResponse::set_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:krpc.schema.ConnectionResponse.message)
}
inline void ConnectionResponse::set_message(const char* value, size_t size) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:krpc.schema.ConnectionResponse.message)
}
inline ::std::string* ConnectionResponse::mutable_message() {
  
  // @@protoc_insertion_point(field_mutable:krpc.schema.ConnectionResponse.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ConnectionResponse::release_message() {
  // @@protoc_insertion_point(field_release:krpc.schema.ConnectionResponse.message)
  
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ConnectionResponse::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    
  } else {
    
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:krpc.schema.ConnectionResponse.message)
}

// bytes client_identifier = 3;
inline void ConnectionResponse::clear_client_identifier() {
  client_identifier_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ConnectionResponse::client_identifier() const {
  // @@protoc_insertion_point(field_get:krpc.schema.ConnectionResponse.client_identifier)
  return client_identifier_.GetNoArena();
}
inline void ConnectionResponse::set_client_identifier(const ::std::string& value) {
  
  client_identifier_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:krpc.schema.ConnectionResponse.client_identifier)
}
#if LANG_CXX11
inline void ConnectionResponse::set_client_identifier(::std::string&& value) {
  
  client_identifier_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:krpc.schema.ConnectionResponse.client_identifier)
}
#endif
inline void ConnectionResponse::set_client_identifier(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  client_identifier_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:krpc.schema.ConnectionResponse.client_identifier)
}
inline void ConnectionResponse::set_client_identifier(const void* value, size_t size) {
  
  client_identifier_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:krpc.schema.ConnectionResponse.client_identifier)
}
inline ::std::string* ConnectionResponse::mutable_client_identifier() {
  
  // @@protoc_insertion_point(field_mutable:krpc.schema.ConnectionResponse.client_identifier)
  return client_identifier_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ConnectionResponse::release_client_identifier() {
  // @@protoc_insertion_point(field_release:krpc.schema.ConnectionResponse.client_identifier)
  
  return client_identifier_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ConnectionResponse::set_allocated_client_identifier(::std::string* client_identifier) {
  if (client_identifier != NULL) {
    
  } else {
    
  }
  client_identifier_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), client_identifier);
  // @@protoc_insertion_point(field_set_allocated:krpc.schema.ConnectionResponse.client_identifier)
}

// -------------------------------------------------------------------

// Request

// repeated .krpc.schema.ProcedureCall calls = 1;
inline int Request::calls_size() const {
  return calls_.size();
}
inline void Request::clear_calls() {
  calls_.Clear();
}
inline ::krpc::schema::ProcedureCall* Request::mutable_calls(int index) {
  // @@protoc_insertion_point(field_mutable:krpc.schema.Request.calls)
  return calls_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::krpc::schema::ProcedureCall >*
Request::mutable_calls() {
  // @@protoc_insertion_point(field_mutable_list:krpc.schema.Request.calls)
  return &calls_;
}
inline const ::krpc::schema::ProcedureCall& Request::calls(int index) const {
  // @@protoc_insertion_point(field_get:krpc.schema.Request.calls)
  return calls_.Get(index);
}
inline ::krpc::schema::ProcedureCall* Request::add_calls() {
  // @@protoc_insertion_point(field_add:krpc.schema.Request.calls)
  return calls_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::krpc::schema::ProcedureCall >&
Request::calls() const {
  // @@protoc_insertion_point(field_list:krpc.schema.Request.calls)
  return calls_;
}

// -------------------------------------------------------------------

// ProcedureCall

// string service = 1;
inline void ProcedureCall::clear_service() {
  service_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ProcedureCall::service() const {
  // @@protoc_insertion_point(field_get:krpc.schema.ProcedureCall.service)
  return service_.GetNoArena();
}
inline void ProcedureCall::set_service(const ::std::string& value) {
  
  service_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:krpc.schema.ProcedureCall.service)
}
#if LANG_CXX11
inline void ProcedureCall::set_service(::std::string&& value) {
  
  service_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:krpc.schema.ProcedureCall.service)
}
#endif
inline void ProcedureCall::set_service(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  service_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:krpc.schema.ProcedureCall.service)
}
inline void ProcedureCall::set_service(const char* value, size_t size) {
  
  service_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:krpc.schema.ProcedureCall.service)
}
inline ::std::string* ProcedureCall::mutable_service() {
  
  // @@protoc_insertion_point(field_mutable:krpc.schema.ProcedureCall.service)
  return service_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ProcedureCall::release_service() {
  // @@protoc_insertion_point(field_release:krpc.schema.ProcedureCall.service)
  
  return service_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ProcedureCall::set_allocated_service(::std::string* service) {
  if (service != NULL) {
    
  } else {
    
  }
  service_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), service);
  // @@protoc_insertion_point(field_set_allocated:krpc.schema.ProcedureCall.service)
}

// string procedure = 2;
inline void ProcedureCall::clear_procedure() {
  procedure_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ProcedureCall::procedure() const {
  // @@protoc_insertion_point(field_get:krpc.schema.ProcedureCall.procedure)
  return procedure_.GetNoArena();
}
inline void ProcedureCall::set_procedure(const ::std::string& value) {
  
  procedure_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:krpc.schema.ProcedureCall.procedure)
}
#if LANG_CXX11
inline void ProcedureCall::set_procedure(::std::string&& value) {
  
  procedure_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:krpc.schema.ProcedureCall.procedure)
}
#endif
inline void ProcedureCall::set_procedure(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  procedure_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:krpc.schema.ProcedureCall.procedure)
}
inline void ProcedureCall::set_procedure(const char* value, size_t size) {
  
  procedure_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:krpc.schema.ProcedureCall.procedure)
}
inline ::std::string* ProcedureCall::mutable_procedure() {
  
  // @@protoc_insertion_point(field_mutable:krpc.schema.ProcedureCall.procedure)
  return procedure_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ProcedureCall::release_procedure() {
  // @@protoc_insertion_point(field_release:krpc.schema.ProcedureCall.procedure)
  
  return procedure_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ProcedureCall::set_allocated_procedure(::std::string* procedure) {
  if (procedure != NULL) {
    
  } else {
    
  }
  procedure_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), procedure);
  // @@protoc_insertion_point(field_set_allocated:krpc.schema.ProcedureCall.procedure)
}

// uint32 service_id = 4;
inline void ProcedureCall::clear_service_id() {
  service_id_ = 0u;
}
inline ::google::protobuf::uint32 ProcedureCall::service_id() const {
  // @@protoc_insertion_point(field_get:krpc.schema.ProcedureCall.service_id)
  return service_id_;
}
inline void ProcedureCall::set_service_id(::google::protobuf::uint32 value) {
  
  service_id_ = value;
  // @@protoc_insertion_point(field_set:krpc.schema.ProcedureCall.service_id)
}

// uint32 procedure_id = 5;
inline void ProcedureCall::clear_procedure_id() {
  procedure_id_ = 0u;
}
inline ::google::protobuf::uint32 ProcedureCall::procedure_id() const {
  // @@protoc_insertion_point(field_get:krpc.schema.ProcedureCall.procedure_id)
  return procedure_id_;
}
inline void ProcedureCall::set_procedure_id(::google::protobuf::uint32 value) {
  
  procedure_id_ = value;
  // @@protoc_insertion_point(field_set:krpc.schema.ProcedureCall.procedure_id)
}

// repeated .krpc.schema.Argument arguments = 3;
inline int ProcedureCall::arguments_size() const {
  return arguments_.size();
}
inline void ProcedureCall::clear_arguments() {
  arguments_.Clear();
}
inline ::krpc::schema::Argument* ProcedureCall::mutable_arguments(int index) {
  // @@protoc_insertion_point(field_mutable:krpc.schema.ProcedureCall.arguments)
  return arguments_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::krpc::schema::Argument >*
ProcedureCall::mutable_arguments() {
  // @@protoc_insertion_point(field_mutable_list:krpc.schema.ProcedureCall.arguments)
  return &arguments_;
}
inline const ::krpc::schema::Argument& ProcedureCall::arguments(int index) const {
  // @@protoc_insertion_point(field_get:krpc.schema.ProcedureCall.arguments)
  return arguments_.Get(index);
}
inline ::krpc::schema::Argument* ProcedureCall::add_arguments() {
  // @@protoc_insertion_point(field_add:krpc.schema.ProcedureCall.arguments)
  return arguments_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::krpc::schema::Argument >&
ProcedureCall::arguments() const {
  // @@protoc_insertion_point(field_list:krpc.schema.ProcedureCall.arguments)
  return arguments_;
}

// -------------------------------------------------------------------

// Argument

// uint32 position = 1;
inline void Argument::clear_position() {
  position_ = 0u;
}
inline ::google::protobuf::uint32 Argument::position() const {
  // @@protoc_insertion_point(field_get:krpc.schema.Argument.position)
  return position_;
}
inline void Argument::set_position(::google::protobuf::uint32 value) {
  
  position_ = value;
  // @@protoc_insertion_point(field_set:krpc.schema.Argument.position)
}

// bytes value = 2;
inline void Argument::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Argument::value() const {
  // @@protoc_insertion_point(field_get:krpc.schema.Argument.value)
  return value_.GetNoArena();
}
inline void Argument::set_value(const ::std::string& value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:krpc.schema.Argument.value)
}
#if LANG_CXX11
inline void Argument::set_value(::std::string&& value) {
  
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:krpc.schema.Argument.value)
}
#endif
inline void Argument::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:krpc.schema.Argument.value)
}
inline void Argument::set_value(const void* value, size_t size) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:krpc.schema.Argument.value)
}
inline ::std::string* Argument::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:krpc.schema.Argument.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Argument::release_value() {
  // @@protoc_insertion_point(field_release:krpc.schema.Argument.value)
  
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Argument::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:krpc.schema.Argument.value)
}

// -------------------------------------------------------------------

// Response

// .krpc.schema.Error error = 1;
inline bool Response::has_error() const {
  return this != internal_default_instance() && error_ != NULL;
}
inline void Response::clear_error() {
  if (GetArenaNoVirtual() == NULL && error_ != NULL) {
    delete error_;
  }
  error_ = NULL;
}
inline const ::krpc::schema::Error& Response::_internal_error() const {
  return *error_;
}
inline const ::krpc::schema::Error& Response::error() const {
  const ::krpc::schema::Error* p = error_;
  // @@protoc_insertion_point(field_get:krpc.schema.Response.error)
  return p != NULL ? *p : *reinterpret_cast<const ::krpc::schema::Error*>(
      &::krpc::schema::_Error_default_instance_);
}
inline ::krpc::schema::Error* Response::release_error() {
  // @@protoc_insertion_point(field_release:krpc.schema.Response.error)
  
  ::krpc::schema::Error* temp = error_;
  error_ = NULL;
  return temp;
}
inline ::krpc::schema::Error* Response::mutable_error() {
  
  if (error_ == NULL) {
    auto* p = CreateMaybeMessage<::krpc::schema::Error>(GetArenaNoVirtual());
    error_ = p;
  }
  // @@protoc_insertion_point(field_mutable:krpc.schema.Response.error)
  return error_;
}
inline void Response::set_allocated_error(::krpc::schema::Error* error) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete error_;
  }
  if (error) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      error = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    
  } else {
    
  }
  error_ = error;
  // @@protoc_insertion_point(field_set_allocated:krpc.schema.Response.error)
}

// repeated .krpc.schema.ProcedureResult results = 2;
inline int Response::results_size() const {
  return results_.size();
}
inline void Response::clear_results() {
  results_.Clear();
}
inline ::krpc::schema::ProcedureResult* Response::mutable_results(int index) {
  // @@protoc_insertion_point(field_mutable:krpc.schema.Response.results)
  return results_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::krpc::schema::ProcedureResult >*
Response::mutable_results() {
  // @@protoc_insertion_point(field_mutable_list:krpc.schema.Response.results)
  return &results_;
}
inline const ::krpc::schema::ProcedureResult& Response::results(int index) const {
  // @@protoc_insertion_point(field_get:krpc.schema.Response.results)
  return results_.Get(index);
}
inline ::krpc::schema::ProcedureResult* Response::add_results() {
  // @@protoc_insertion_point(field_add:krpc.schema.Response.results)
  return results_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::krpc::schema::ProcedureResult >&
Response::results() const {
  // @@protoc_insertion_point(field_list:krpc.schema.Response.results)
  return results_;
}

// -------------------------------------------------------------------

// ProcedureResult

// .krpc.schema.Error error = 1;
inline bool ProcedureResult::has_error() const {
  return this != internal_default_instance() && error_ != NULL;
}
inline void ProcedureResult::clear_error() {
  if (GetArenaNoVirtual() == NULL && error_ != NULL) {
    delete error_;
  }
  error_ = NULL;
}
inline const ::krpc::schema::Error& ProcedureResult::_internal_error() const {
  return *error_;
}
inline const ::krpc::schema::Error& ProcedureResult::error() const {
  const ::krpc::schema::Error* p = error_;
  // @@protoc_insertion_point(field_get:krpc.schema.ProcedureResult.error)
  return p != NULL ? *p : *reinterpret_cast<const ::krpc::schema::Error*>(
      &::krpc::schema::_Error_default_instance_);
}
inline ::krpc::schema::Error* ProcedureResult::release_error() {
  // @@protoc_insertion_point(field_release:krpc.schema.ProcedureResult.error)
  
  ::krpc::schema::Error* temp = error_;
  error_ = NULL;
  return temp;
}
inline ::krpc::schema::Error* ProcedureResult::mutable_error() {
  
  if (error_ == NULL) {
    auto* p = CreateMaybeMessage<::krpc::schema::Error>(GetArenaNoVirtual());
    error_ = p;
  }
  // @@protoc_insertion_point(field_mutable:krpc.schema.ProcedureResult.error)
  return error_;
}
inline void ProcedureResult::set_allocated_error(::krpc::schema::Error* error) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete error_;
  }
  if (error) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      error = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    
  } else {
    
  }
  error_ = error;
  // @@protoc_insertion_point(field_set_allocated:krpc.schema.ProcedureResult.error)
}

// bytes value = 2;
inline void ProcedureResult::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ProcedureResult::value() const {
  // @@protoc_insertion_point(field_get:krpc.schema.ProcedureResult.value)
  return value_.GetNoArena();
}
inline void ProcedureResult::set_value(const ::std::string& value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:krpc.schema.ProcedureResult.value)
}
#if LANG_CXX11
inline void ProcedureResult::set_value(::std::string&& value) {
  
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:krpc.schema.ProcedureResult.value)
}
#endif
inline void ProcedureResult::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:krpc.schema.ProcedureResult.value)
}
inline void ProcedureResult::set_value(const void* value, size_t size) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:krpc.schema.ProcedureResult.value)
}
inline ::std::string* ProcedureResult::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:krpc.schema.ProcedureResult.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ProcedureResult::release_value() {
  // @@protoc_insertion_point(field_release:krpc.schema.ProcedureResult.value)
  
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ProcedureResult::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:krpc.schema.ProcedureResult.value)
}

// -------------------------------------------------------------------

// Error

// string service = 1;
inline void Error::clear_service() {
  service_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Error::service() const {
  // @@protoc_insertion_point(field_get:krpc.schema.Error.service)
  return service_.GetNoArena();
}
inline void Error::set_service(const ::std::string& value) {
  
  service_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:krpc.schema.Error.service)
}
#if LANG_CXX11
inline void Error::set_service(::std::string&& value) {
  
  service_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:krpc.schema.Error.service)
}
#endif
inline void Error::set_service(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  service_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:krpc.schema.Error.service)
}
inline void Error::set_service(const char* value, size_t size) {
  
  service_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:krpc.schema.Error.service)
}
inline ::std::string* Error::mutable_service() {
  
  // @@protoc_insertion_point(field_mutable:krpc.schema.Error.service)
  return service_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Error::release_service() {
  // @@protoc_insertion_point(field_release:krpc.schema.Error.service)
  
  return service_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Error::set_allocated_service(::std::string* service) {
  if (service != NULL) {
    
  } else {
    
  }
  service_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), service);
  // @@protoc_insertion_point(field_set_allocated:krpc.schema.Error.service)
}

// string name = 2;
inline void Error::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Error::name() const {
  // @@protoc_insertion_point(field_get:krpc.schema.Error.name)
  return name_.GetNoArena();
}
inline void Error::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:krpc.schema.Error.name)
}
#if LANG_CXX11
inline void Error::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:krpc.schema.Error.name)
}
#endif
inline void Error::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:krpc.schema.Error.name)
}
inline void Error::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:krpc.schema.Error.name)
}
inline ::std::string* Error::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:krpc.schema.Error.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Error::release_name() {
  // @@protoc_insertion_point(field_release:krpc.schema.Error.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Error::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:krpc.schema.Error.name)
}

// string description = 3;
inline void Error::clear_description() {
  description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Error::description() const {
  // @@protoc_insertion_point(field_get:krpc.schema.Error.description)
  return description_.GetNoArena();
}
inline void Error::set_description(const ::std::string& value) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:krpc.schema.Error.description)
}
#if LANG_CXX11
inline void Error::set_description(::std::string&& value) {
  
  description_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:krpc.schema.Error.description)
}
#endif
inline void Error::set_description(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:krpc.schema.Error.description)
}
inline void Error::set_description(const char* value, size_t size) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:krpc.schema.Error.description)
}
inline ::std::string* Error::mutable_description() {
  
  // @@protoc_insertion_point(field_mutable:krpc.schema.Error.description)
  return description_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Error::release_description() {
  // @@protoc_insertion_point(field_release:krpc.schema.Error.description)
  
  return description_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Error::set_allocated_description(::std::string* description) {
  if (description != NULL) {
    
  } else {
    
  }
  description_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), description);
  // @@protoc_insertion_point(field_set_allocated:krpc.schema.Error.description)
}

// string stack_trace = 4;
inline void Error::clear_stack_trace() {
  stack_trace_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Error::stack_trace() const {
  // @@protoc_insertion_point(field_get:krpc.schema.Error.stack_trace)
  return stack_trace_.GetNoArena();
}
inline void Error::set_stack_trace(const ::std::string& value) {
  
  stack_trace_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:krpc.schema.Error.stack_trace)
}
#if LANG_CXX11
inline void Error::set_stack_trace(::std::string&& value) {
  
  stack_trace_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:krpc.schema.Error.stack_trace)
}
#endif
inline void Error::set_stack_trace(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  stack_trace_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:krpc.schema.Error.stack_trace)
}
inline void Error::set_stack_trace(const char* value, size_t size) {
  
  stack_trace_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:krpc.schema.Error.stack_trace)
}
inline ::std::string* Error::mutable_stack_trace() {
  
  // @@protoc_insertion_point(field_mutable:krpc.schema.Error.stack_trace)
  return stack_trace_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Error::release_stack_trace() {
  // @@protoc_insertion_point(field_release:krpc.schema.Error.stack_trace)
  
  return stack_trace_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Error::set_allocated_stack_trace(::std::string* stack_trace) {
  if (stack_trace != NULL) {
    
  } else {
    
  }
  stack_trace_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), stack_trace);
  // @@protoc_insertion_point(field_set_allocated:krpc.schema.Error.stack_trace)
}

// -------------------------------------------------------------------

// StreamUpdate

// repeated .krpc.schema.StreamResult results = 1;
inline int StreamUpdate::results_size() const {
  return results_.size();
}
inline void StreamUpdate::clear_results() {
  results_.Clear();
}
inline ::krpc::schema::StreamResult* StreamUpdate::mutable_results(int index) {
  // @@protoc_insertion_point(field_mutable:krpc.schema.StreamUpdate.results)
  return results_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::krpc::schema::StreamResult >*
StreamUpdate::mutable_results() {
  // @@protoc_insertion_point(field_mutable_list:krpc.schema.StreamUpdate.results)
  return &results_;
}
inline const ::krpc::schema::StreamResult& StreamUpdate::results(int index) const {
  // @@protoc_insertion_point(field_get:krpc.schema.StreamUpdate.results)
  return results_.Get(index);
}
inline ::krpc::schema::StreamResult* StreamUpdate::add_results() {
  // @@protoc_insertion_point(field_add:krpc.schema.StreamUpdate.results)
  return results_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::krpc::schema::StreamResult >&
StreamUpdate::results() const {
  // @@protoc_insertion_point(field_list:krpc.schema.StreamUpdate.results)
  return results_;
}

// -------------------------------------------------------------------

// StreamResult

// uint64 id = 1;
inline void StreamResult::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 StreamResult::id() const {
  // @@protoc_insertion_point(field_get:krpc.schema.StreamResult.id)
  return id_;
}
inline void StreamResult::set_id(::google::protobuf::uint64 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:krpc.schema.StreamResult.id)
}

// .krpc.schema.ProcedureResult result = 2;
inline bool StreamResult::has_result() const {
  return this != internal_default_instance() && result_ != NULL;
}
inline void StreamResult::clear_result() {
  if (GetArenaNoVirtual() == NULL && result_ != NULL) {
    delete result_;
  }
  result_ = NULL;
}
inline const ::krpc::schema::ProcedureResult& StreamResult::_internal_result() const {
  return *result_;
}
inline const ::krpc::schema::ProcedureResult& StreamResult::result() const {
  const ::krpc::schema::ProcedureResult* p = result_;
  // @@protoc_insertion_point(field_get:krpc.schema.StreamResult.result)
  return p != NULL ? *p : *reinterpret_cast<const ::krpc::schema::ProcedureResult*>(
      &::krpc::schema::_ProcedureResult_default_instance_);
}
inline ::krpc::schema::ProcedureResult* StreamResult::release_result() {
  // @@protoc_insertion_point(field_release:krpc.schema.StreamResult.result)
  
  ::krpc::schema::ProcedureResult* temp = result_;
  result_ = NULL;
  return temp;
}
inline ::krpc::schema::ProcedureResult* StreamResult::mutable_result() {
  
  if (result_ == NULL) {
    auto* p = CreateMaybeMessage<::krpc::schema::ProcedureResult>(GetArenaNoVirtual());
    result_ = p;
  }
  // @@protoc_insertion_point(field_mutable:krpc.schema.StreamResult.result)
  return result_;
}
inline void StreamResult::set_allocated_result(::krpc::schema::ProcedureResult* result) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete result_;
  }
  if (result) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      result = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, result, submessage_arena);
    }
    
  } else {
    
  }
  result_ = result;
  // @@protoc_insertion_point(field_set_allocated:krpc.schema.StreamResult.result)
}

// -------------------------------------------------------------------

// Services

// repeated .krpc.schema.Service services = 1;
inline int Services::services_size() const {
  return services_.size();
}
inline void Services::clear_services() {
  services_.Clear();
}
inline ::krpc::schema::Service* Services::mutable_services(int index) {
  // @@protoc_insertion_point(field_mutable:krpc.schema.Services.services)
  return services_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::krpc::schema::Service >*
Services::mutable_services() {
  // @@protoc_insertion_point(field_mutable_list:krpc.schema.Services.services)
  return &services_;
}
inline const ::krpc::schema::Service& Services::services(int index) const {
  // @@protoc_insertion_point(field_get:krpc.schema.Services.services)
  return services_.Get(index);
}
inline ::krpc::schema::Service* Services::add_services() {
  // @@protoc_insertion_point(field_add:krpc.schema.Services.services)
  return services_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::krpc::schema::Service >&
Services::services() const {
  // @@protoc_insertion_point(field_list:krpc.schema.Services.services)
  return services_;
}

// -------------------------------------------------------------------

// Service

// string name = 1;
inline void Service::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Service::name() const {
  // @@protoc_insertion_point(field_get:krpc.schema.Service.name)
  return name_.GetNoArena();
}
inline void Service::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:krpc.schema.Service.name)
}
#if LANG_CXX11
inline void Service::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:krpc.schema.Service.name)
}
#endif
inline void Service::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:krpc.schema.Service.name)
}
inline void Service::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:krpc.schema.Service.name)
}
inline ::std::string* Service::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:krpc.schema.Service.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Service::release_name() {
  // @@protoc_insertion_point(field_release:krpc.schema.Service.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Service::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:krpc.schema.Service.name)
}

// repeated .krpc.schema.Procedure procedures = 2;
inline int Service::procedures_size() const {
  return procedures_.size();
}
inline void Service::clear_procedures() {
  procedures_.Clear();
}
inline ::krpc::schema::Procedure* Service::mutable_procedures(int index) {
  // @@protoc_insertion_point(field_mutable:krpc.schema.Service.procedures)
  return procedures_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::krpc::schema::Procedure >*
Service::mutable_procedures() {
  // @@protoc_insertion_point(field_mutable_list:krpc.schema.Service.procedures)
  return &procedures_;
}
inline const ::krpc::schema::Procedure& Service::procedures(int index) const {
  // @@protoc_insertion_point(field_get:krpc.schema.Service.procedures)
  return procedures_.Get(index);
}
inline ::krpc::schema::Procedure* Service::add_procedures() {
  // @@protoc_insertion_point(field_add:krpc.schema.Service.procedures)
  return procedures_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::krpc::schema::Procedure >&
Service::procedures() const {
  // @@protoc_insertion_point(field_list:krpc.schema.Service.procedures)
  return procedures_;
}

// repeated .krpc.schema.Class classes = 3;
inline int Service::classes_size() const {
  return classes_.size();
}
inline void Service::clear_classes() {
  classes_.Clear();
}
inline ::krpc::schema::Class* Service::mutable_classes(int index) {
  // @@protoc_insertion_point(field_mutable:krpc.schema.Service.classes)
  return classes_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::krpc::schema::Class >*
Service::mutable_classes() {
  // @@protoc_insertion_point(field_mutable_list:krpc.schema.Service.classes)
  return &classes_;
}
inline const ::krpc::schema::Class& Service::classes(int index) const {
  // @@protoc_insertion_point(field_get:krpc.schema.Service.classes)
  return classes_.Get(index);
}
inline ::krpc::schema::Class* Service::add_classes() {
  // @@protoc_insertion_point(field_add:krpc.schema.Service.classes)
  return classes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::krpc::schema::Class >&
Service::classes() const {
  // @@protoc_insertion_point(field_list:krpc.schema.Service.classes)
  return classes_;
}

// repeated .krpc.schema.Enumeration enumerations = 4;
inline int Service::enumerations_size() const {
  return enumerations_.size();
}
inline void Service::clear_enumerations() {
  enumerations_.Clear();
}
inline ::krpc::schema::Enumeration* Service::mutable_enumerations(int index) {
  // @@protoc_insertion_point(field_mutable:krpc.schema.Service.enumerations)
  return enumerations_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::krpc::schema::Enumeration >*
Service::mutable_enumerations() {
  // @@protoc_insertion_point(field_mutable_list:krpc.schema.Service.enumerations)
  return &enumerations_;
}
inline const ::krpc::schema::Enumeration& Service::enumerations(int index) const {
  // @@protoc_insertion_point(field_get:krpc.schema.Service.enumerations)
  return enumerations_.Get(index);
}
inline ::krpc::schema::Enumeration* Service::add_enumerations() {
  // @@protoc_insertion_point(field_add:krpc.schema.Service.enumerations)
  return enumerations_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::krpc::schema::Enumeration >&
Service::enumerations() const {
  // @@protoc_insertion_point(field_list:krpc.schema.Service.enumerations)
  return enumerations_;
}

// repeated .krpc.schema.Exception exceptions = 5;
inline int Service::exceptions_size() const {
  return exceptions_.size();
}
inline void Service::clear_exceptions() {
  exceptions_.Clear();
}
inline ::krpc::schema::Exception* Service::mutable_exceptions(int index) {
  // @@protoc_insertion_point(field_mutable:krpc.schema.Service.exceptions)
  return exceptions_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::krpc::schema::Exception >*
Service::mutable_exceptions() {
  // @@protoc_insertion_point(field_mutable_list:krpc.schema.Service.exceptions)
  return &exceptions_;
}
inline const ::krpc::schema::Exception& Service::exceptions(int index) const {
  // @@protoc_insertion_point(field_get:krpc.schema.Service.exceptions)
  return exceptions_.Get(index);
}
inline ::krpc::schema::Exception* Service::add_exceptions() {
  // @@protoc_insertion_point(field_add:krpc.schema.Service.exceptions)
  return exceptions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::krpc::schema::Exception >&
Service::exceptions() const {
  // @@protoc_insertion_point(field_list:krpc.schema.Service.exceptions)
  return exceptions_;
}

// string documentation = 6;
inline void Service::clear_documentation() {
  documentation_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Service::documentation() const {
  // @@protoc_insertion_point(field_get:krpc.schema.Service.documentation)
  return documentation_.GetNoArena();
}
inline void Service::set_documentation(const ::std::string& value) {
  
  documentation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:krpc.schema.Service.documentation)
}
#if LANG_CXX11
inline void Service::set_documentation(::std::string&& value) {
  
  documentation_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:krpc.schema.Service.documentation)
}
#endif
inline void Service::set_documentation(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  documentation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:krpc.schema.Service.documentation)
}
inline void Service::set_documentation(const char* value, size_t size) {
  
  documentation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:krpc.schema.Service.documentation)
}
inline ::std::string* Service::mutable_documentation() {
  
  // @@protoc_insertion_point(field_mutable:krpc.schema.Service.documentation)
  return documentation_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Service::release_documentation() {
  // @@protoc_insertion_point(field_release:krpc.schema.Service.documentation)
  
  return documentation_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Service::set_allocated_documentation(::std::string* documentation) {
  if (documentation != NULL) {
    
  } else {
    
  }
  documentation_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), documentation);
  // @@protoc_insertion_point(field_set_allocated:krpc.schema.Service.documentation)
}

// -------------------------------------------------------------------

// Procedure

// string name = 1;
inline void Procedure::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Procedure::name() const {
  // @@protoc_insertion_point(field_get:krpc.schema.Procedure.name)
  return name_.GetNoArena();
}
inline void Procedure::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:krpc.schema.Procedure.name)
}
#if LANG_CXX11
inline void Procedure::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:krpc.schema.Procedure.name)
}
#endif
inline void Procedure::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:krpc.schema.Procedure.name)
}
inline void Procedure::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:krpc.schema.Procedure.name)
}
inline ::std::string* Procedure::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:krpc.schema.Procedure.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Procedure::release_name() {
  // @@protoc_insertion_point(field_release:krpc.schema.Procedure.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Procedure::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:krpc.schema.Procedure.name)
}

// repeated .krpc.schema.Parameter parameters = 2;
inline int Procedure::parameters_size() const {
  return parameters_.size();
}
inline void Procedure::clear_parameters() {
  parameters_.Clear();
}
inline ::krpc::schema::Parameter* Procedure::mutable_parameters(int index) {
  // @@protoc_insertion_point(field_mutable:krpc.schema.Procedure.parameters)
  return parameters_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::krpc::schema::Parameter >*
Procedure::mutable_parameters() {
  // @@protoc_insertion_point(field_mutable_list:krpc.schema.Procedure.parameters)
  return &parameters_;
}
inline const ::krpc::schema::Parameter& Procedure::parameters(int index) const {
  // @@protoc_insertion_point(field_get:krpc.schema.Procedure.parameters)
  return parameters_.Get(index);
}
inline ::krpc::schema::Parameter* Procedure::add_parameters() {
  // @@protoc_insertion_point(field_add:krpc.schema.Procedure.parameters)
  return parameters_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::krpc::schema::Parameter >&
Procedure::parameters() const {
  // @@protoc_insertion_point(field_list:krpc.schema.Procedure.parameters)
  return parameters_;
}

// .krpc.schema.Type return_type = 3;
inline bool Procedure::has_return_type() const {
  return this != internal_default_instance() && return_type_ != NULL;
}
inline void Procedure::clear_return_type() {
  if (GetArenaNoVirtual() == NULL && return_type_ != NULL) {
    delete return_type_;
  }
  return_type_ = NULL;
}
inline const ::krpc::schema::Type& Procedure::_internal_return_type() const {
  return *return_type_;
}
inline const ::krpc::schema::Type& Procedure::return_type() const {
  const ::krpc::schema::Type* p = return_type_;
  // @@protoc_insertion_point(field_get:krpc.schema.Procedure.return_type)
  return p != NULL ? *p : *reinterpret_cast<const ::krpc::schema::Type*>(
      &::krpc::schema::_Type_default_instance_);
}
inline ::krpc::schema::Type* Procedure::release_return_type() {
  // @@protoc_insertion_point(field_release:krpc.schema.Procedure.return_type)
  
  ::krpc::schema::Type* temp = return_type_;
  return_type_ = NULL;
  return temp;
}
inline ::krpc::schema::Type* Procedure::mutable_return_type() {
  
  if (return_type_ == NULL) {
    auto* p = CreateMaybeMessage<::krpc::schema::Type>(GetArenaNoVirtual());
    return_type_ = p;
  }
  // @@protoc_insertion_point(field_mutable:krpc.schema.Procedure.return_type)
  return return_type_;
}
inline void Procedure::set_allocated_return_type(::krpc::schema::Type* return_type) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete return_type_;
  }
  if (return_type) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      return_type = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, return_type, submessage_arena);
    }
    
  } else {
    
  }
  return_type_ = return_type;
  // @@protoc_insertion_point(field_set_allocated:krpc.schema.Procedure.return_type)
}

// bool return_is_nullable = 4;
inline void Procedure::clear_return_is_nullable() {
  return_is_nullable_ = false;
}
inline bool Procedure::return_is_nullable() const {
  // @@protoc_insertion_point(field_get:krpc.schema.Procedure.return_is_nullable)
  return return_is_nullable_;
}
inline void Procedure::set_return_is_nullable(bool value) {
  
  return_is_nullable_ = value;
  // @@protoc_insertion_point(field_set:krpc.schema.Procedure.return_is_nullable)
}

// repeated .krpc.schema.Procedure.GameScene game_scenes = 6;
inline int Procedure::game_scenes_size() const {
  return game_scenes_.size();
}
inline void Procedure::clear_game_scenes() {
  game_scenes_.Clear();
}
inline ::krpc::schema::Procedure_GameScene Procedure::game_scenes(int index) const {
  // @@protoc_insertion_point(field_get:krpc.schema.Procedure.game_scenes)
  return static_cast< ::krpc::schema::Procedure_GameScene >(game_scenes_.Get(index));
}
inline void Procedure::set_game_scenes(int index, ::krpc::schema::Procedure_GameScene value) {
  game_scenes_.Set(index, value);
  // @@protoc_insertion_point(field_set:krpc.schema.Procedure.game_scenes)
}
inline void Procedure::add_game_scenes(::krpc::schema::Procedure_GameScene value) {
  game_scenes_.Add(value);
  // @@protoc_insertion_point(field_add:krpc.schema.Procedure.game_scenes)
}
inline const ::google::protobuf::RepeatedField<int>&
Procedure::game_scenes() const {
  // @@protoc_insertion_point(field_list:krpc.schema.Procedure.game_scenes)
  return game_scenes_;
}
inline ::google::protobuf::RepeatedField<int>*
Procedure::mutable_game_scenes() {
  // @@protoc_insertion_point(field_mutable_list:krpc.schema.Procedure.game_scenes)
  return &game_scenes_;
}

// string documentation = 5;
inline void Procedure::clear_documentation() {
  documentation_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Procedure::documentation() const {
  // @@protoc_insertion_point(field_get:krpc.schema.Procedure.documentation)
  return documentation_.GetNoArena();
}
inline void Procedure::set_documentation(const ::std::string& value) {
  
  documentation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:krpc.schema.Procedure.documentation)
}
#if LANG_CXX11
inline void Procedure::set_documentation(::std::string&& value) {
  
  documentation_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:krpc.schema.Procedure.documentation)
}
#endif
inline void Procedure::set_documentation(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  documentation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:krpc.schema.Procedure.documentation)
}
inline void Procedure::set_documentation(const char* value, size_t size) {
  
  documentation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:krpc.schema.Procedure.documentation)
}
inline ::std::string* Procedure::mutable_documentation() {
  
  // @@protoc_insertion_point(field_mutable:krpc.schema.Procedure.documentation)
  return documentation_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Procedure::release_documentation() {
  // @@protoc_insertion_point(field_release:krpc.schema.Procedure.documentation)
  
  return documentation_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Procedure::set_allocated_documentation(::std::string* documentation) {
  if (documentation != NULL) {
    
  } else {
    
  }
  documentation_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), documentation);
  // @@protoc_insertion_point(field_set_allocated:krpc.schema.Procedure.documentation)
}

// -------------------------------------------------------------------

// Parameter

// string name = 1;
inline void Parameter::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Parameter::name() const {
  // @@protoc_insertion_point(field_get:krpc.schema.Parameter.name)
  return name_.GetNoArena();
}
inline void Parameter::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:krpc.schema.Parameter.name)
}
#if LANG_CXX11
inline void Parameter::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:krpc.schema.Parameter.name)
}
#endif
inline void Parameter::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:krpc.schema.Parameter.name)
}
inline void Parameter::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:krpc.schema.Parameter.name)
}
inline ::std::string* Parameter::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:krpc.schema.Parameter.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Parameter::release_name() {
  // @@protoc_insertion_point(field_release:krpc.schema.Parameter.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Parameter::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:krpc.schema.Parameter.name)
}

// .krpc.schema.Type type = 2;
inline bool Parameter::has_type() const {
  return this != internal_default_instance() && type_ != NULL;
}
inline void Parameter::clear_type() {
  if (GetArenaNoVirtual() == NULL && type_ != NULL) {
    delete type_;
  }
  type_ = NULL;
}
inline const ::krpc::schema::Type& Parameter::_internal_type() const {
  return *type_;
}
inline const ::krpc::schema::Type& Parameter::type() const {
  const ::krpc::schema::Type* p = type_;
  // @@protoc_insertion_point(field_get:krpc.schema.Parameter.type)
  return p != NULL ? *p : *reinterpret_cast<const ::krpc::schema::Type*>(
      &::krpc::schema::_Type_default_instance_);
}
inline ::krpc::schema::Type* Parameter::release_type() {
  // @@protoc_insertion_point(field_release:krpc.schema.Parameter.type)
  
  ::krpc::schema::Type* temp = type_;
  type_ = NULL;
  return temp;
}
inline ::krpc::schema::Type* Parameter::mutable_type() {
  
  if (type_ == NULL) {
    auto* p = CreateMaybeMessage<::krpc::schema::Type>(GetArenaNoVirtual());
    type_ = p;
  }
  // @@protoc_insertion_point(field_mutable:krpc.schema.Parameter.type)
  return type_;
}
inline void Parameter::set_allocated_type(::krpc::schema::Type* type) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete type_;
  }
  if (type) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      type = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, type, submessage_arena);
    }
    
  } else {
    
  }
  type_ = type;
  // @@protoc_insertion_point(field_set_allocated:krpc.schema.Parameter.type)
}

// bytes default_value = 3;
inline void Parameter::clear_default_value() {
  default_value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Parameter::default_value() const {
  // @@protoc_insertion_point(field_get:krpc.schema.Parameter.default_value)
  return default_value_.GetNoArena();
}
inline void Parameter::set_default_value(const ::std::string& value) {
  
  default_value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:krpc.schema.Parameter.default_value)
}
#if LANG_CXX11
inline void Parameter::set_default_value(::std::string&& value) {
  
  default_value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:krpc.schema.Parameter.default_value)
}
#endif
inline void Parameter::set_default_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  default_value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:krpc.schema.Parameter.default_value)
}
inline void Parameter::set_default_value(const void* value, size_t size) {
  
  default_value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:krpc.schema.Parameter.default_value)
}
inline ::std::string* Parameter::mutable_default_value() {
  
  // @@protoc_insertion_point(field_mutable:krpc.schema.Parameter.default_value)
  return default_value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Parameter::release_default_value() {
  // @@protoc_insertion_point(field_release:krpc.schema.Parameter.default_value)
  
  return default_value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Parameter::set_allocated_default_value(::std::string* default_value) {
  if (default_value != NULL) {
    
  } else {
    
  }
  default_value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), default_value);
  // @@protoc_insertion_point(field_set_allocated:krpc.schema.Parameter.default_value)
}

// -------------------------------------------------------------------

// Class

// string name = 1;
inline void Class::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Class::name() const {
  // @@protoc_insertion_point(field_get:krpc.schema.Class.name)
  return name_.GetNoArena();
}
inline void Class::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:krpc.schema.Class.name)
}
#if LANG_CXX11
inline void Class::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:krpc.schema.Class.name)
}
#endif
inline void Class::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:krpc.schema.Class.name)
}
inline void Class::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:krpc.schema.Class.name)
}
inline ::std::string* Class::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:krpc.schema.Class.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Class::release_name() {
  // @@protoc_insertion_point(field_release:krpc.schema.Class.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Class::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:krpc.schema.Class.name)
}

// string documentation = 2;
inline void Class::clear_documentation() {
  documentation_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Class::documentation() const {
  // @@protoc_insertion_point(field_get:krpc.schema.Class.documentation)
  return documentation_.GetNoArena();
}
inline void Class::set_documentation(const ::std::string& value) {
  
  documentation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:krpc.schema.Class.documentation)
}
#if LANG_CXX11
inline void Class::set_documentation(::std::string&& value) {
  
  documentation_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:krpc.schema.Class.documentation)
}
#endif
inline void Class::set_documentation(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  documentation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:krpc.schema.Class.documentation)
}
inline void Class::set_documentation(const char* value, size_t size) {
  
  documentation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:krpc.schema.Class.documentation)
}
inline ::std::string* Class::mutable_documentation() {
  
  // @@protoc_insertion_point(field_mutable:krpc.schema.Class.documentation)
  return documentation_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Class::release_documentation() {
  // @@protoc_insertion_point(field_release:krpc.schema.Class.documentation)
  
  return documentation_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Class::set_allocated_documentation(::std::string* documentation) {
  if (documentation != NULL) {
    
  } else {
    
  }
  documentation_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), documentation);
  // @@protoc_insertion_point(field_set_allocated:krpc.schema.Class.documentation)
}

// -------------------------------------------------------------------

// Enumeration

// string name = 1;
inline void Enumeration::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Enumeration::name() const {
  // @@protoc_insertion_point(field_get:krpc.schema.Enumeration.name)
  return name_.GetNoArena();
}
inline void Enumeration::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:krpc.schema.Enumeration.name)
}
#if LANG_CXX11
inline void Enumeration::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:krpc.schema.Enumeration.name)
}
#endif
inline void Enumeration::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:krpc.schema.Enumeration.name)
}
inline void Enumeration::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:krpc.schema.Enumeration.name)
}
inline ::std::string* Enumeration::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:krpc.schema.Enumeration.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Enumeration::release_name() {
  // @@protoc_insertion_point(field_release:krpc.schema.Enumeration.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Enumeration::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:krpc.schema.Enumeration.name)
}

// repeated .krpc.schema.EnumerationValue values = 2;
inline int Enumeration::values_size() const {
  return values_.size();
}
inline void Enumeration::clear_values() {
  values_.Clear();
}
inline ::krpc::schema::EnumerationValue* Enumeration::mutable_values(int index) {
  // @@protoc_insertion_point(field_mutable:krpc.schema.Enumeration.values)
  return values_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::krpc::schema::EnumerationValue >*
Enumeration::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:krpc.schema.Enumeration.values)
  return &values_;
}
inline const ::krpc::schema::EnumerationValue& Enumeration::values(int index) const {
  // @@protoc_insertion_point(field_get:krpc.schema.Enumeration.values)
  return values_.Get(index);
}
inline ::krpc::schema::EnumerationValue* Enumeration::add_values() {
  // @@protoc_insertion_point(field_add:krpc.schema.Enumeration.values)
  return values_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::krpc::schema::EnumerationValue >&
Enumeration::values() const {
  // @@protoc_insertion_point(field_list:krpc.schema.Enumeration.values)
  return values_;
}

// string documentation = 3;
inline void Enumeration::clear_documentation() {
  documentation_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Enumeration::documentation() const {
  // @@protoc_insertion_point(field_get:krpc.schema.Enumeration.documentation)
  return documentation_.GetNoArena();
}
inline void Enumeration::set_documentation(const ::std::string& value) {
  
  documentation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:krpc.schema.Enumeration.documentation)
}
#if LANG_CXX11
inline void Enumeration::set_documentation(::std::string&& value) {
  
  documentation_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:krpc.schema.Enumeration.documentation)
}
#endif
inline void Enumeration::set_documentation(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  documentation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:krpc.schema.Enumeration.documentation)
}
inline void Enumeration::set_documentation(const char* value, size_t size) {
  
  documentation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:krpc.schema.Enumeration.documentation)
}
inline ::std::string* Enumeration::mutable_documentation() {
  
  // @@protoc_insertion_point(field_mutable:krpc.schema.Enumeration.documentation)
  return documentation_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Enumeration::release_documentation() {
  // @@protoc_insertion_point(field_release:krpc.schema.Enumeration.documentation)
  
  return documentation_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Enumeration::set_allocated_documentation(::std::string* documentation) {
  if (documentation != NULL) {
    
  } else {
    
  }
  documentation_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), documentation);
  // @@protoc_insertion_point(field_set_allocated:krpc.schema.Enumeration.documentation)
}

// -------------------------------------------------------------------

// EnumerationValue

// string name = 1;
inline void EnumerationValue::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& EnumerationValue::name() const {
  // @@protoc_insertion_point(field_get:krpc.schema.EnumerationValue.name)
  return name_.GetNoArena();
}
inline void EnumerationValue::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:krpc.schema.EnumerationValue.name)
}
#if LANG_CXX11
inline void EnumerationValue::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:krpc.schema.EnumerationValue.name)
}
#endif
inline void EnumerationValue::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:krpc.schema.EnumerationValue.name)
}
inline void EnumerationValue::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:krpc.schema.EnumerationValue.name)
}
inline ::std::string* EnumerationValue::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:krpc.schema.EnumerationValue.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EnumerationValue::release_name() {
  // @@protoc_insertion_point(field_release:krpc.schema.EnumerationValue.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EnumerationValue::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:krpc.schema.EnumerationValue.name)
}

// int32 value = 2;
inline void EnumerationValue::clear_value() {
  value_ = 0;
}
inline ::google::protobuf::int32 EnumerationValue::value() const {
  // @@protoc_insertion_point(field_get:krpc.schema.EnumerationValue.value)
  return value_;
}
inline void EnumerationValue::set_value(::google::protobuf::int32 value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:krpc.schema.EnumerationValue.value)
}

// string documentation = 3;
inline void EnumerationValue::clear_documentation() {
  documentation_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& EnumerationValue::documentation() const {
  // @@protoc_insertion_point(field_get:krpc.schema.EnumerationValue.documentation)
  return documentation_.GetNoArena();
}
inline void EnumerationValue::set_documentation(const ::std::string& value) {
  
  documentation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:krpc.schema.EnumerationValue.documentation)
}
#if LANG_CXX11
inline void EnumerationValue::set_documentation(::std::string&& value) {
  
  documentation_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:krpc.schema.EnumerationValue.documentation)
}
#endif
inline void EnumerationValue::set_documentation(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  documentation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:krpc.schema.EnumerationValue.documentation)
}
inline void EnumerationValue::set_documentation(const char* value, size_t size) {
  
  documentation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:krpc.schema.EnumerationValue.documentation)
}
inline ::std::string* EnumerationValue::mutable_documentation() {
  
  // @@protoc_insertion_point(field_mutable:krpc.schema.EnumerationValue.documentation)
  return documentation_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EnumerationValue::release_documentation() {
  // @@protoc_insertion_point(field_release:krpc.schema.EnumerationValue.documentation)
  
  return documentation_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EnumerationValue::set_allocated_documentation(::std::string* documentation) {
  if (documentation != NULL) {
    
  } else {
    
  }
  documentation_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), documentation);
  // @@protoc_insertion_point(field_set_allocated:krpc.schema.EnumerationValue.documentation)
}

// -------------------------------------------------------------------

// Exception

// string name = 1;
inline void Exception::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Exception::name() const {
  // @@protoc_insertion_point(field_get:krpc.schema.Exception.name)
  return name_.GetNoArena();
}
inline void Exception::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:krpc.schema.Exception.name)
}
#if LANG_CXX11
inline void Exception::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:krpc.schema.Exception.name)
}
#endif
inline void Exception::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:krpc.schema.Exception.name)
}
inline void Exception::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:krpc.schema.Exception.name)
}
inline ::std::string* Exception::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:krpc.schema.Exception.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Exception::release_name() {
  // @@protoc_insertion_point(field_release:krpc.schema.Exception.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Exception::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:krpc.schema.Exception.name)
}

// string documentation = 2;
inline void Exception::clear_documentation() {
  documentation_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Exception::documentation() const {
  // @@protoc_insertion_point(field_get:krpc.schema.Exception.documentation)
  return documentation_.GetNoArena();
}
inline void Exception::set_documentation(const ::std::string& value) {
  
  documentation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:krpc.schema.Exception.documentation)
}
#if LANG_CXX11
inline void Exception::set_documentation(::std::string&& value) {
  
  documentation_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:krpc.schema.Exception.documentation)
}
#endif
inline void Exception::set_documentation(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  documentation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:krpc.schema.Exception.documentation)
}
inline void Exception::set_documentation(const char* value, size_t size) {
  
  documentation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:krpc.schema.Exception.documentation)
}
inline ::std::string* Exception::mutable_documentation() {
  
  // @@protoc_insertion_point(field_mutable:krpc.schema.Exception.documentation)
  return documentation_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Exception::release_documentation() {
  // @@protoc_insertion_point(field_release:krpc.schema.Exception.documentation)
  
  return documentation_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Exception::set_allocated_documentation(::std::string* documentation) {
  if (documentation != NULL) {
    
  } else {
    
  }
  documentation_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), documentation);
  // @@protoc_insertion_point(field_set_allocated:krpc.schema.Exception.documentation)
}

// -------------------------------------------------------------------

// Type

// .krpc.schema.Type.TypeCode code = 1;
inline void Type::clear_code() {
  code_ = 0;
}
inline ::krpc::schema::Type_TypeCode Type::code() const {
  // @@protoc_insertion_point(field_get:krpc.schema.Type.code)
  return static_cast< ::krpc::schema::Type_TypeCode >(code_);
}
inline void Type::set_code(::krpc::schema::Type_TypeCode value) {
  
  code_ = value;
  // @@protoc_insertion_point(field_set:krpc.schema.Type.code)
}

// string service = 2;
inline void Type::clear_service() {
  service_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Type::service() const {
  // @@protoc_insertion_point(field_get:krpc.schema.Type.service)
  return service_.GetNoArena();
}
inline void Type::set_service(const ::std::string& value) {
  
  service_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:krpc.schema.Type.service)
}
#if LANG_CXX11
inline void Type::set_service(::std::string&& value) {
  
  service_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:krpc.schema.Type.service)
}
#endif
inline void Type::set_service(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  service_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:krpc.schema.Type.service)
}
inline void Type::set_service(const char* value, size_t size) {
  
  service_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:krpc.schema.Type.service)
}
inline ::std::string* Type::mutable_service() {
  
  // @@protoc_insertion_point(field_mutable:krpc.schema.Type.service)
  return service_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Type::release_service() {
  // @@protoc_insertion_point(field_release:krpc.schema.Type.service)
  
  return service_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Type::set_allocated_service(::std::string* service) {
  if (service != NULL) {
    
  } else {
    
  }
  service_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), service);
  // @@protoc_insertion_point(field_set_allocated:krpc.schema.Type.service)
}

// string name = 3;
inline void Type::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Type::name() const {
  // @@protoc_insertion_point(field_get:krpc.schema.Type.name)
  return name_.GetNoArena();
}
inline void Type::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:krpc.schema.Type.name)
}
#if LANG_CXX11
inline void Type::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:krpc.schema.Type.name)
}
#endif
inline void Type::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:krpc.schema.Type.name)
}
inline void Type::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:krpc.schema.Type.name)
}
inline ::std::string* Type::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:krpc.schema.Type.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Type::release_name() {
  // @@protoc_insertion_point(field_release:krpc.schema.Type.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Type::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:krpc.schema.Type.name)
}

// repeated .krpc.schema.Type types = 4;
inline int Type::types_size() const {
  return types_.size();
}
inline void Type::clear_types() {
  types_.Clear();
}
inline ::krpc::schema::Type* Type::mutable_types(int index) {
  // @@protoc_insertion_point(field_mutable:krpc.schema.Type.types)
  return types_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::krpc::schema::Type >*
Type::mutable_types() {
  // @@protoc_insertion_point(field_mutable_list:krpc.schema.Type.types)
  return &types_;
}
inline const ::krpc::schema::Type& Type::types(int index) const {
  // @@protoc_insertion_point(field_get:krpc.schema.Type.types)
  return types_.Get(index);
}
inline ::krpc::schema::Type* Type::add_types() {
  // @@protoc_insertion_point(field_add:krpc.schema.Type.types)
  return types_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::krpc::schema::Type >&
Type::types() const {
  // @@protoc_insertion_point(field_list:krpc.schema.Type.types)
  return types_;
}

// -------------------------------------------------------------------

// Tuple

// repeated bytes items = 1;
inline int Tuple::items_size() const {
  return items_.size();
}
inline void Tuple::clear_items() {
  items_.Clear();
}
inline const ::std::string& Tuple::items(int index) const {
  // @@protoc_insertion_point(field_get:krpc.schema.Tuple.items)
  return items_.Get(index);
}
inline ::std::string* Tuple::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:krpc.schema.Tuple.items)
  return items_.Mutable(index);
}
inline void Tuple::set_items(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:krpc.schema.Tuple.items)
  items_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Tuple::set_items(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:krpc.schema.Tuple.items)
  items_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Tuple::set_items(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  items_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:krpc.schema.Tuple.items)
}
inline void Tuple::set_items(int index, const void* value, size_t size) {
  items_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:krpc.schema.Tuple.items)
}
inline ::std::string* Tuple::add_items() {
  // @@protoc_insertion_point(field_add_mutable:krpc.schema.Tuple.items)
  return items_.Add();
}
inline void Tuple::add_items(const ::std::string& value) {
  items_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:krpc.schema.Tuple.items)
}
#if LANG_CXX11
inline void Tuple::add_items(::std::string&& value) {
  items_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:krpc.schema.Tuple.items)
}
#endif
inline void Tuple::add_items(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  items_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:krpc.schema.Tuple.items)
}
inline void Tuple::add_items(const void* value, size_t size) {
  items_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:krpc.schema.Tuple.items)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Tuple::items() const {
  // @@protoc_insertion_point(field_list:krpc.schema.Tuple.items)
  return items_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Tuple::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:krpc.schema.Tuple.items)
  return &items_;
}

// -------------------------------------------------------------------

// List

// repeated bytes items = 1;
inline int List::items_size() const {
  return items_.size();
}
inline void List::clear_items() {
  items_.Clear();
}
inline const ::std::string& List::items(int index) const {
  // @@protoc_insertion_point(field_get:krpc.schema.List.items)
  return items_.Get(index);
}
inline ::std::string* List::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:krpc.schema.List.items)
  return items_.Mutable(index);
}
inline void List::set_items(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:krpc.schema.List.items)
  items_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void List::set_items(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:krpc.schema.List.items)
  items_.Mutable(index)->assign(std::move(value));
}
#endif
inline void List::set_items(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  items_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:krpc.schema.List.items)
}
inline void List::set_items(int index, const void* value, size_t size) {
  items_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:krpc.schema.List.items)
}
inline ::std::string* List::add_items() {
  // @@protoc_insertion_point(field_add_mutable:krpc.schema.List.items)
  return items_.Add();
}
inline void List::add_items(const ::std::string& value) {
  items_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:krpc.schema.List.items)
}
#if LANG_CXX11
inline void List::add_items(::std::string&& value) {
  items_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:krpc.schema.List.items)
}
#endif
inline void List::add_items(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  items_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:krpc.schema.List.items)
}
inline void List::add_items(const void* value, size_t size) {
  items_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:krpc.schema.List.items)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
List::items() const {
  // @@protoc_insertion_point(field_list:krpc.schema.List.items)
  return items_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
List::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:krpc.schema.List.items)
  return &items_;
}

// -------------------------------------------------------------------

// Set

// repeated bytes items = 1;
inline int Set::items_size() const {
  return items_.size();
}
inline void Set::clear_items() {
  items_.Clear();
}
inline const ::std::string& Set::items(int index) const {
  // @@protoc_insertion_point(field_get:krpc.schema.Set.items)
  return items_.Get(index);
}
inline ::std::string* Set::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:krpc.schema.Set.items)
  return items_.Mutable(index);
}
inline void Set::set_items(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:krpc.schema.Set.items)
  items_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Set::set_items(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:krpc.schema.Set.items)
  items_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Set::set_items(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  items_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:krpc.schema.Set.items)
}
inline void Set::set_items(int index, const void* value, size_t size) {
  items_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:krpc.schema.Set.items)
}
inline ::std::string* Set::add_items() {
  // @@protoc_insertion_point(field_add_mutable:krpc.schema.Set.items)
  return items_.Add();
}
inline void Set::add_items(const ::std::string& value) {
  items_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:krpc.schema.Set.items)
}
#if LANG_CXX11
inline void Set::add_items(::std::string&& value) {
  items_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:krpc.schema.Set.items)
}
#endif
inline void Set::add_items(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  items_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:krpc.schema.Set.items)
}
inline void Set::add_items(const void* value, size_t size) {
  items_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:krpc.schema.Set.items)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Set::items() const {
  // @@protoc_insertion_point(field_list:krpc.schema.Set.items)
  return items_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Set::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:krpc.schema.Set.items)
  return &items_;
}

// -------------------------------------------------------------------

// Dictionary

// repeated .krpc.schema.DictionaryEntry entries = 1;
inline int Dictionary::entries_size() const {
  return entries_.size();
}
inline void Dictionary::clear_entries() {
  entries_.Clear();
}
inline ::krpc::schema::DictionaryEntry* Dictionary::mutable_entries(int index) {
  // @@protoc_insertion_point(field_mutable:krpc.schema.Dictionary.entries)
  return entries_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::krpc::schema::DictionaryEntry >*
Dictionary::mutable_entries() {
  // @@protoc_insertion_point(field_mutable_list:krpc.schema.Dictionary.entries)
  return &entries_;
}
inline const ::krpc::schema::DictionaryEntry& Dictionary::entries(int index) const {
  // @@protoc_insertion_point(field_get:krpc.schema.Dictionary.entries)
  return entries_.Get(index);
}
inline ::krpc::schema::DictionaryEntry* Dictionary::add_entries() {
  // @@protoc_insertion_point(field_add:krpc.schema.Dictionary.entries)
  return entries_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::krpc::schema::DictionaryEntry >&
Dictionary::entries() const {
  // @@protoc_insertion_point(field_list:krpc.schema.Dictionary.entries)
  return entries_;
}

// -------------------------------------------------------------------

// DictionaryEntry

// bytes key = 1;
inline void DictionaryEntry::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DictionaryEntry::key() const {
  // @@protoc_insertion_point(field_get:krpc.schema.DictionaryEntry.key)
  return key_.GetNoArena();
}
inline void DictionaryEntry::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:krpc.schema.DictionaryEntry.key)
}
#if LANG_CXX11
inline void DictionaryEntry::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:krpc.schema.DictionaryEntry.key)
}
#endif
inline void DictionaryEntry::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:krpc.schema.DictionaryEntry.key)
}
inline void DictionaryEntry::set_key(const void* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:krpc.schema.DictionaryEntry.key)
}
inline ::std::string* DictionaryEntry::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:krpc.schema.DictionaryEntry.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DictionaryEntry::release_key() {
  // @@protoc_insertion_point(field_release:krpc.schema.DictionaryEntry.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DictionaryEntry::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:krpc.schema.DictionaryEntry.key)
}

// bytes value = 2;
inline void DictionaryEntry::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DictionaryEntry::value() const {
  // @@protoc_insertion_point(field_get:krpc.schema.DictionaryEntry.value)
  return value_.GetNoArena();
}
inline void DictionaryEntry::set_value(const ::std::string& value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:krpc.schema.DictionaryEntry.value)
}
#if LANG_CXX11
inline void DictionaryEntry::set_value(::std::string&& value) {
  
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:krpc.schema.DictionaryEntry.value)
}
#endif
inline void DictionaryEntry::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:krpc.schema.DictionaryEntry.value)
}
inline void DictionaryEntry::set_value(const void* value, size_t size) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:krpc.schema.DictionaryEntry.value)
}
inline ::std::string* DictionaryEntry::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:krpc.schema.DictionaryEntry.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DictionaryEntry::release_value() {
  // @@protoc_insertion_point(field_release:krpc.schema.DictionaryEntry.value)
  
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DictionaryEntry::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:krpc.schema.DictionaryEntry.value)
}

// -------------------------------------------------------------------

// Stream

// uint64 id = 1;
inline void Stream::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Stream::id() const {
  // @@protoc_insertion_point(field_get:krpc.schema.Stream.id)
  return id_;
}
inline void Stream::set_id(::google::protobuf::uint64 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:krpc.schema.Stream.id)
}

// -------------------------------------------------------------------

// Event

// .krpc.schema.Stream stream = 1;
inline bool Event::has_stream() const {
  return this != internal_default_instance() && stream_ != NULL;
}
inline void Event::clear_stream() {
  if (GetArenaNoVirtual() == NULL && stream_ != NULL) {
    delete stream_;
  }
  stream_ = NULL;
}
inline const ::krpc::schema::Stream& Event::_internal_stream() const {
  return *stream_;
}
inline const ::krpc::schema::Stream& Event::stream() const {
  const ::krpc::schema::Stream* p = stream_;
  // @@protoc_insertion_point(field_get:krpc.schema.Event.stream)
  return p != NULL ? *p : *reinterpret_cast<const ::krpc::schema::Stream*>(
      &::krpc::schema::_Stream_default_instance_);
}
inline ::krpc::schema::Stream* Event::release_stream() {
  // @@protoc_insertion_point(field_release:krpc.schema.Event.stream)
  
  ::krpc::schema::Stream* temp = stream_;
  stream_ = NULL;
  return temp;
}
inline ::krpc::schema::Stream* Event::mutable_stream() {
  
  if (stream_ == NULL) {
    auto* p = CreateMaybeMessage<::krpc::schema::Stream>(GetArenaNoVirtual());
    stream_ = p;
  }
  // @@protoc_insertion_point(field_mutable:krpc.schema.Event.stream)
  return stream_;
}
inline void Event::set_allocated_stream(::krpc::schema::Stream* stream) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete stream_;
  }
  if (stream) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      stream = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, stream, submessage_arena);
    }
    
  } else {
    
  }
  stream_ = stream;
  // @@protoc_insertion_point(field_set_allocated:krpc.schema.Event.stream)
}

// -------------------------------------------------------------------

// Status

// string version = 1;
inline void Status::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Status::version() const {
  // @@protoc_insertion_point(field_get:krpc.schema.Status.version)
  return version_.GetNoArena();
}
inline void Status::set_version(const ::std::string& value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:krpc.schema.Status.version)
}
#if LANG_CXX11
inline void Status::set_version(::std::string&& value) {
  
  version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:krpc.schema.Status.version)
}
#endif
inline void Status::set_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:krpc.schema.Status.version)
}
inline void Status::set_version(const char* value, size_t size) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:krpc.schema.Status.version)
}
inline ::std::string* Status::mutable_version() {
  
  // @@protoc_insertion_point(field_mutable:krpc.schema.Status.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Status::release_version() {
  // @@protoc_insertion_point(field_release:krpc.schema.Status.version)
  
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Status::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    
  } else {
    
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:krpc.schema.Status.version)
}

// uint64 bytes_read = 2;
inline void Status::clear_bytes_read() {
  bytes_read_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Status::bytes_read() const {
  // @@protoc_insertion_point(field_get:krpc.schema.Status.bytes_read)
  return bytes_read_;
}
inline void Status::set_bytes_read(::google::protobuf::uint64 value) {
  
  bytes_read_ = value;
  // @@protoc_insertion_point(field_set:krpc.schema.Status.bytes_read)
}

// uint64 bytes_written = 3;
inline void Status::clear_bytes_written() {
  bytes_written_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Status::bytes_written() const {
  // @@protoc_insertion_point(field_get:krpc.schema.Status.bytes_written)
  return bytes_written_;
}
inline void Status::set_bytes_written(::google::protobuf::uint64 value) {
  
  bytes_written_ = value;
  // @@protoc_insertion_point(field_set:krpc.schema.Status.bytes_written)
}

// float bytes_read_rate = 4;
inline void Status::clear_bytes_read_rate() {
  bytes_read_rate_ = 0;
}
inline float Status::bytes_read_rate() const {
  // @@protoc_insertion_point(field_get:krpc.schema.Status.bytes_read_rate)
  return bytes_read_rate_;
}
inline void Status::set_bytes_read_rate(float value) {
  
  bytes_read_rate_ = value;
  // @@protoc_insertion_point(field_set:krpc.schema.Status.bytes_read_rate)
}

// float bytes_written_rate = 5;
inline void Status::clear_bytes_written_rate() {
  bytes_written_rate_ = 0;
}
inline float Status::bytes_written_rate() const {
  // @@protoc_insertion_point(field_get:krpc.schema.Status.bytes_written_rate)
  return bytes_written_rate_;
}
inline void Status::set_bytes_written_rate(float value) {
  
  bytes_written_rate_ = value;
  // @@protoc_insertion_point(field_set:krpc.schema.Status.bytes_written_rate)
}

// uint64 rpcs_executed = 6;
inline void Status::clear_rpcs_executed() {
  rpcs_executed_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Status::rpcs_executed() const {
  // @@protoc_insertion_point(field_get:krpc.schema.Status.rpcs_executed)
  return rpcs_executed_;
}
inline void Status::set_rpcs_executed(::google::protobuf::uint64 value) {
  
  rpcs_executed_ = value;
  // @@protoc_insertion_point(field_set:krpc.schema.Status.rpcs_executed)
}

// float rpc_rate = 7;
inline void Status::clear_rpc_rate() {
  rpc_rate_ = 0;
}
inline float Status::rpc_rate() const {
  // @@protoc_insertion_point(field_get:krpc.schema.Status.rpc_rate)
  return rpc_rate_;
}
inline void Status::set_rpc_rate(float value) {
  
  rpc_rate_ = value;
  // @@protoc_insertion_point(field_set:krpc.schema.Status.rpc_rate)
}

// bool one_rpc_per_update = 8;
inline void Status::clear_one_rpc_per_update() {
  one_rpc_per_update_ = false;
}
inline bool Status::one_rpc_per_update() const {
  // @@protoc_insertion_point(field_get:krpc.schema.Status.one_rpc_per_update)
  return one_rpc_per_update_;
}
inline void Status::set_one_rpc_per_update(bool value) {
  
  one_rpc_per_update_ = value;
  // @@protoc_insertion_point(field_set:krpc.schema.Status.one_rpc_per_update)
}

// uint32 max_time_per_update = 9;
inline void Status::clear_max_time_per_update() {
  max_time_per_update_ = 0u;
}
inline ::google::protobuf::uint32 Status::max_time_per_update() const {
  // @@protoc_insertion_point(field_get:krpc.schema.Status.max_time_per_update)
  return max_time_per_update_;
}
inline void Status::set_max_time_per_update(::google::protobuf::uint32 value) {
  
  max_time_per_update_ = value;
  // @@protoc_insertion_point(field_set:krpc.schema.Status.max_time_per_update)
}

// bool adaptive_rate_control = 10;
inline void Status::clear_adaptive_rate_control() {
  adaptive_rate_control_ = false;
}
inline bool Status::adaptive_rate_control() const {
  // @@protoc_insertion_point(field_get:krpc.schema.Status.adaptive_rate_control)
  return adaptive_rate_control_;
}
inline void Status::set_adaptive_rate_control(bool value) {
  
  adaptive_rate_control_ = value;
  // @@protoc_insertion_point(field_set:krpc.schema.Status.adaptive_rate_control)
}

// bool blocking_recv = 11;
inline void Status::clear_blocking_recv() {
  blocking_recv_ = false;
}
inline bool Status::blocking_recv() const {
  // @@protoc_insertion_point(field_get:krpc.schema.Status.blocking_recv)
  return blocking_recv_;
}
inline void Status::set_blocking_recv(bool value) {
  
  blocking_recv_ = value;
  // @@protoc_insertion_point(field_set:krpc.schema.Status.blocking_recv)
}

// uint32 recv_timeout = 12;
inline void Status::clear_recv_timeout() {
  recv_timeout_ = 0u;
}
inline ::google::protobuf::uint32 Status::recv_timeout() const {
  // @@protoc_insertion_point(field_get:krpc.schema.Status.recv_timeout)
  return recv_timeout_;
}
inline void Status::set_recv_timeout(::google::protobuf::uint32 value) {
  
  recv_timeout_ = value;
  // @@protoc_insertion_point(field_set:krpc.schema.Status.recv_timeout)
}

// float time_per_rpc_update = 13;
inline void Status::clear_time_per_rpc_update() {
  time_per_rpc_update_ = 0;
}
inline float Status::time_per_rpc_update() const {
  // @@protoc_insertion_point(field_get:krpc.schema.Status.time_per_rpc_update)
  return time_per_rpc_update_;
}
inline void Status::set_time_per_rpc_update(float value) {
  
  time_per_rpc_update_ = value;
  // @@protoc_insertion_point(field_set:krpc.schema.Status.time_per_rpc_update)
}

// float poll_time_per_rpc_update = 14;
inline void Status::clear_poll_time_per_rpc_update() {
  poll_time_per_rpc_update_ = 0;
}
inline float Status::poll_time_per_rpc_update() const {
  // @@protoc_insertion_point(field_get:krpc.schema.Status.poll_time_per_rpc_update)
  return poll_time_per_rpc_update_;
}
inline void Status::set_poll_time_per_rpc_update(float value) {
  
  poll_time_per_rpc_update_ = value;
  // @@protoc_insertion_point(field_set:krpc.schema.Status.poll_time_per_rpc_update)
}

// float exec_time_per_rpc_update = 15;
inline void Status::clear_exec_time_per_rpc_update() {
  exec_time_per_rpc_update_ = 0;
}
inline float Status::exec_time_per_rpc_update() const {
  // @@protoc_insertion_point(field_get:krpc.schema.Status.exec_time_per_rpc_update)
  return exec_time_per_rpc_update_;
}
inline void Status::set_exec_time_per_rpc_update(float value) {
  
  exec_time_per_rpc_update_ = value;
  // @@protoc_insertion_point(field_set:krpc.schema.Status.exec_time_per_rpc_update)
}

// uint32 stream_rpcs = 16;
inline void Status::clear_stream_rpcs() {
  stream_rpcs_ = 0u;
}
inline ::google::protobuf::uint32 Status::stream_rpcs() const {
  // @@protoc_insertion_point(field_get:krpc.schema.Status.stream_rpcs)
  return stream_rpcs_;
}
inline void Status::set_stream_rpcs(::google::protobuf::uint32 value) {
  
  stream_rpcs_ = value;
  // @@protoc_insertion_point(field_set:krpc.schema.Status.stream_rpcs)
}

// uint64 stream_rpcs_executed = 17;
inline void Status::clear_stream_rpcs_executed() {
  stream_rpcs_executed_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Status::stream_rpcs_executed() const {
  // @@protoc_insertion_point(field_get:krpc.schema.Status.stream_rpcs_executed)
  return stream_rpcs_executed_;
}
inline void Status::set_stream_rpcs_executed(::google::protobuf::uint64 value) {
  
  stream_rpcs_executed_ = value;
  // @@protoc_insertion_point(field_set:krpc.schema.Status.stream_rpcs_executed)
}

// float stream_rpc_rate = 18;
inline void Status::clear_stream_rpc_rate() {
  stream_rpc_rate_ = 0;
}
inline float Status::stream_rpc_rate() const {
  // @@protoc_insertion_point(field_get:krpc.schema.Status.stream_rpc_rate)
  return stream_rpc_rate_;
}
inline void Status::set_stream_rpc_rate(float value) {
  
  stream_rpc_rate_ = value;
  // @@protoc_insertion_point(field_set:krpc.schema.Status.stream_rpc_rate)
}

// float time_per_stream_update = 19;
inline void Status::clear_time_per_stream_update() {
  time_per_stream_update_ = 0;
}
inline float Status::time_per_stream_update() const {
  // @@protoc_insertion_point(field_get:krpc.schema.Status.time_per_stream_update)
  return time_per_stream_update_;
}
inline void Status::set_time_per_stream_update(float value) {
  
  time_per_stream_update_ = value;
  // @@protoc_insertion_point(field_set:krpc.schema.Status.time_per_stream_update)
}

// -------------------------------------------------------------------

// MultiplexedRequest

// .krpc.schema.ConnectionRequest connection_request = 1;
inline bool MultiplexedRequest::has_connection_request() const {
  return this != internal_default_instance() && connection_request_ != NULL;
}
inline void MultiplexedRequest::clear_connection_request() {
  if (GetArenaNoVirtual() == NULL && connection_request_ != NULL) {
    delete connection_request_;
  }
  connection_request_ = NULL;
}
inline const ::krpc::schema::ConnectionRequest& MultiplexedRequest::_internal_connection_request() const {
  return *connection_request_;
}
inline const ::krpc::schema::ConnectionRequest& MultiplexedRequest::connection_request() const {
  const ::krpc::schema::ConnectionRequest* p = connection_request_;
  // @@protoc_insertion_point(field_get:krpc.schema.MultiplexedRequest.connection_request)
  return p != NULL ? *p : *reinterpret_cast<const ::krpc::schema::ConnectionRequest*>(
      &::krpc::schema::_ConnectionRequest_default_instance_);
}
inline ::krpc::schema::ConnectionRequest* MultiplexedRequest::release_connection_request() {
  // @@protoc_insertion_point(field_release:krpc.schema.MultiplexedRequest.connection_request)
  
  ::krpc::schema::ConnectionRequest* temp = connection_request_;
  connection_request_ = NULL;
  return temp;
}
inline ::krpc::schema::ConnectionRequest* MultiplexedRequest::mutable_connection_request() {
  
  if (connection_request_ == NULL) {
    auto* p = CreateMaybeMessage<::krpc::schema::ConnectionRequest>(GetArenaNoVirtual());
    connection_request_ = p;
  }
  // @@protoc_insertion_point(field_mutable:krpc.schema.MultiplexedRequest.connection_request)
  return connection_request_;
}
inline void MultiplexedRequest::set_allocated_connection_request(::krpc::schema::ConnectionRequest* connection_request) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete connection_request_;
  }
  if (connection_request) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      connection_request = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, connection_request, submessage_arena);
    }
    
  } else {
    
  }
  connection_request_ = connection_request;
  // @@protoc_insertion_point(field_set_allocated:krpc.schema.MultiplexedRequest.connection_request)
}

// .krpc.schema.Request request = 2;
inline bool MultiplexedRequest::has_request() const {
  return this != internal_default_instance() && request_ != NULL;
}
inline void MultiplexedRequest::clear_request() {
  if (GetArenaNoVirtual() == NULL && request_ != NULL) {
    delete request_;
  }
  request_ = NULL;
}
inline const ::krpc::schema::Request& MultiplexedRequest::_internal_request() const {
  return *request_;
}
inline const ::krpc::schema::Request& MultiplexedRequest::request() const {
  const ::krpc::schema::Request* p = request_;
  // @@protoc_insertion_point(field_get:krpc.schema.MultiplexedRequest.request)
  return p != NULL ? *p : *reinterpret_cast<const ::krpc::schema::Request*>(
      &::krpc::schema::_Request_default_instance_);
}
inline ::krpc::schema::Request* MultiplexedRequest::release_request() {
  // @@protoc_insertion_point(field_release:krpc.schema.MultiplexedRequest.request)
  
  ::krpc::schema::Request* temp = request_;
  request_ = NULL;
  return temp;
}
inline ::krpc::schema::Request* MultiplexedRequest::mutable_request() {
  
  if (request_ == NULL) {
    auto* p = CreateMaybeMessage<::krpc::schema::Request>(GetArenaNoVirtual());
    request_ = p;
  }
  // @@protoc_insertion_point(field_mutable:krpc.schema.MultiplexedRequest.request)
  return request_;
}
inline void MultiplexedRequest::set_allocated_request(::krpc::schema::Request* request) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete request_;
  }
  if (request) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      request = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    
  } else {
    
  }
  request_ = request;
  // @@protoc_insertion_point(field_set_allocated:krpc.schema.MultiplexedRequest.request)
}

// -------------------------------------------------------------------

// MultiplexedResponse

// .krpc.schema.Response response = 1;
inline bool MultiplexedResponse::has_response() const {
  return this != internal_default_instance() && response_ != NULL;
}
inline void MultiplexedResponse::clear_response() {
  if (GetArenaNoVirtual() == NULL && response_ != NULL) {
    delete response_;
  }
  response_ = NULL;
}
inline const ::krpc::schema::Response& MultiplexedResponse::_internal_response() const {
  return *response_;
}
inline const ::krpc::schema::Response& MultiplexedResponse::response() const {
  const ::krpc::schema::Response* p = response_;
  // @@protoc_insertion_point(field_get:krpc.schema.MultiplexedResponse.response)
  return p != NULL ? *p : *reinterpret_cast<const ::krpc::schema::Response*>(
      &::krpc::schema::_Response_default_instance_);
}
inline ::krpc::schema::Response* MultiplexedResponse::release_response() {
  // @@protoc_insertion_point(field_release:krpc.schema.MultiplexedResponse.response)
  
  ::krpc::schema::Response* temp = response_;
  response_ = NULL;
  return temp;
}
inline ::krpc::schema::Response* MultiplexedResponse::mutable_response() {
  
  if (response_ == NULL) {
    auto* p = CreateMaybeMessage<::krpc::schema::Response>(GetArenaNoVirtual());
    response_ = p;
  }
  // @@protoc_insertion_point(field_mutable:krpc.schema.MultiplexedResponse.response)
  return response_;
}
inline void MultiplexedResponse::set_allocated_response(::krpc::schema::Response* response) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete response_;
  }
  if (response) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      response = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  response_ = response;
  // @@protoc_insertion_point(field_set_allocated:krpc.schema.MultiplexedResponse.response)
}

// .krpc.schema.StreamUpdate stream_update = 2;
inline bool MultiplexedResponse::has_stream_update() const {
  return this != internal_default_instance() && stream_update_ != NULL;
}
inline void MultiplexedResponse::clear_stream_update() {
  if (GetArenaNoVirtual() == NULL && stream_update_ != NULL) {
    delete stream_update_;
  }
  stream_update_ = NULL;
}
inline const ::krpc::schema::StreamUpdate& MultiplexedResponse::_internal_stream_update() const {
  return *stream_update_;
}
inline const ::krpc::schema::StreamUpdate& MultiplexedResponse::stream_update() const {
  const ::krpc::schema::StreamUpdate* p = stream_update_;
  // @@protoc_insertion_point(field_get:krpc.schema.MultiplexedResponse.stream_update)
  return p != NULL ? *p : *reinterpret_cast<const ::krpc::schema::StreamUpdate*>(
      &::krpc::schema::_StreamUpdate_default_instance_);
}
inline ::krpc::schema::StreamUpdate* MultiplexedResponse::release_stream_update() {
  // @@protoc_insertion_point(field_release:krpc.schema.MultiplexedResponse.stream_update)
  
  ::krpc::schema::StreamUpdate* temp = stream_update_;
  stream_update_ = NULL;
  return temp;
}
inline ::krpc::schema::StreamUpdate* MultiplexedResponse::mutable_stream_update() {
  
  if (stream_update_ == NULL) {
    auto* p = CreateMaybeMessage<::krpc::schema::StreamUpdate>(GetArenaNoVirtual());
    stream_update_ = p;
  }
  // @@protoc_insertion_point(field_mutable:krpc.schema.MultiplexedResponse.stream_update)
  return stream_update_;
}
inline void MultiplexedResponse::set_allocated_stream_update(::krpc::schema::StreamUpdate* stream_update) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete stream_update_;
  }
  if (stream_update) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      stream_update = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, stream_update, submessage_arena);
    }
    
  } else {
    
  }
  stream_update_ = stream_update;
  // @@protoc_insertion_point(field_set_allocated:krpc.schema.MultiplexedResponse.stream_update)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace schema
}  // namespace krpc

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::krpc::schema::ConnectionRequest_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::krpc::schema::ConnectionRequest_Type>() {
  return ::krpc::schema::ConnectionRequest_Type_descriptor();
}
template <> struct is_proto_enum< ::krpc::schema::ConnectionResponse_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::krpc::schema::ConnectionResponse_Status>() {
  return ::krpc::schema::ConnectionResponse_Status_descriptor();
}
template <> struct is_proto_enum< ::krpc::schema::Procedure_GameScene> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::krpc::schema::Procedure_GameScene>() {
  return ::krpc::schema::Procedure_GameScene_descriptor();
}
template <> struct is_proto_enum< ::krpc::schema::Type_TypeCode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::krpc::schema::Type_TypeCode>() {
  return ::krpc::schema::Type_TypeCode_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_krpc_2eproto
